# 8. **Dev bootstrap + CLI**

   * Files: `src/LimboDancer.MCP.Cli/{Program.cs, Commands/*}`, `docs/DEVSETUP.md`, `appsettings.Development.json`.
   * Verbs: `serve --stdio`, `db migrate`, `vector init`, `kg ping`, `mem add/search`.
   * Why: Improves DX and hits the Roadmap DX tasks.&#x20;
   
   ---
   
   Awesome — here’s a **developer bootstrap + CLI** you can drop in.
It gives you a single CLI with verbs:

* `serve --stdio` (stubbed spot to wire the MCP stdio server)
* `db migrate` (apply EF migrations for Chat + Audit stores)
* `vector init` (ensure Azure AI Search index exists)
* `kg ping` (round-trip to Cosmos Gremlin)
* `mem add` (chunk + embed + upsert into Search)
* `mem search` (hybrid search with optional filters)

It also includes a concise **DEVSETUP.md** and a **dev appsettings**.

---

## `src/LimboDancer.MCP.Cli/Program.cs`

```csharp
using System.CommandLine;
using Microsoft.Extensions.Configuration;
using Microsoft.Extensions.DependencyInjection;
using Microsoft.Extensions.Hosting;

// Local libs
using LimboDancer.MCP.Cli.Commands;

var root = new RootCommand("LimboDancer.MCP CLI");

var serve = ServeCommand.Build();
var db    = DbMigrateCommand.Build();
var vector= VectorInitCommand.Build();
var kg    = KgPingCommand.Build();
var memAdd= MemAddCommand.Build();
var memSearch = MemSearchCommand.Build();

root.AddCommand(serve);
root.AddCommand(db);
root.AddCommand(vector);
root.AddCommand(kg);
root.AddCommand(memAdd);
root.AddCommand(memSearch);

// Standard host builder used by all commands
static IHost BuildHost(string[]? args)
{
    var builder = Host.CreateApplicationBuilder(args ?? Array.Empty<string>());

    // Configuration precedence: appsettings.Development.json → env → secrets
    builder.Configuration
        .AddJsonFile("appsettings.json", optional: true)
        .AddJsonFile("appsettings.Development.json", optional: true)
        .AddEnvironmentVariables();

    ServicesBootstrap.Configure(builder);

    return builder.Build();
}

return await root.InvokeAsync(args);
```

---

## `src/LimboDancer.MCP.Cli/Commands/ServicesBootstrap.cs`

```csharp
using Azure;
using Azure.Search.Documents;
using Azure.Search.Documents.Indexes;
using Gremlin.Net.Driver;
using LimboDancer.MCP.Audit;
using LimboDancer.MCP.Graph.CosmosGremlin;
using LimboDancer.MCP.Storage;
using LimboDancer.MCP.Vector.AzureSearch;
using Microsoft.EntityFrameworkCore;
using Microsoft.Extensions.Configuration;
using Microsoft.Extensions.DependencyInjection;

namespace LimboDancer.MCP.Cli.Commands;

internal static class ServicesBootstrap
{
    public static void Configure(HostApplicationBuilder b)
    {
        var cfg = b.Configuration;

        // EF: Chat
        b.Services.AddDbContext<ChatDbContext>(opt =>
        {
            var cs = cfg["Persistence:ConnectionString"]!;
            opt.UseNpgsql(cs);
        });

        // EF: Audit
        b.Services.AddDbContext<AuditDbContext>(opt =>
        {
            var cs = cfg["Audit:ConnectionString"] ?? cfg["Persistence:ConnectionString"]!;
            opt.UseNpgsql(cs);
        });

        b.Services.AddScoped<IChatHistoryStore, ChatHistoryStore>();

        // Azure AI Search
        b.Services.AddSingleton<SearchIndexClient>(sp =>
        {
            var endpoint = new Uri(cfg["Search:Endpoint"]!);
            var key = new AzureKeyCredential(cfg["Search:ApiKey"]!);
            return new SearchIndexClient(endpoint, key);
        });
        b.Services.AddSingleton<SearchClient>(sp =>
        {
            var endpoint = new Uri(cfg["Search:Endpoint"]!);
            var key = new AzureKeyCredential(cfg["Search:ApiKey"]!);
            var idx = cfg["Search:Index"] ?? "ldm-memory";
            return new SearchClient(endpoint, idx, key);
        });

        // Vector store (no default embed delegate; commands wire one if needed)
        b.Services.AddSingleton<VectorStore>();

        // Gremlin
        b.Services.AddSingleton<IGremlinClient>(sp =>
        {
            var opts = new GremlinOptions
            {
                Host = cfg["Gremlin:Host"]!,
                Port = int.TryParse(cfg["Gremlin:Port"], out var p) ? p : 443,
                Database = cfg["Gremlin:Database"]!,
                Graph = cfg["Gremlin:Graph"]!,
                PrimaryKey = cfg["Gremlin:Key"]!
            };
            return GremlinClientFactory.Create(opts);
        });
    }
}
```

---

## `src/LimboDancer.MCP.Cli/Commands/ServeCommand.cs`

```csharp
using System.CommandLine;
using Microsoft.Extensions.Hosting;

namespace LimboDancer.MCP.Cli.Commands;

internal static class ServeCommand
{
    public static Command Build()
    {
        var cmd = new Command("serve", "Run the MCP server");
        var stdio = new Option<bool>("--stdio", description: "Run in stdio mode (MCP over stdio).");
        cmd.AddOption(stdio);

        cmd.SetHandler(async (bool useStdio) =>
        {
            using var host = BuildHost(null);

            if (useStdio)
            {
                // Thin-slice placeholder: wire your Stdio server runner here.
                // Example (when you have an SDK runner available):
                // var runner = host.Services.GetRequiredService<McpStdioRunner>();
                // await runner.RunAsync();
                Console.WriteLine("serve --stdio: stub runner in CLI. Wire your MCP stdio host here.");
                return;
            }

            Console.WriteLine("No HTTP runner exposed via CLI. Use your McpServer.Http project to host the HTTP endpoints.");
        }, stdio);

        return cmd;
    }

    private static IHost BuildHost(string[]? args) => Program
        .GetType()
        .Assembly
        .GetType("Program") is null // satisfy static analysis; we call the same bootstrap as Program.cs
        ? Host.CreateDefaultBuilder(args).Build()
        : (IHost)typeof(Program).Assembly
            .GetType("Program")!
            .GetMethod("BuildHost", System.Reflection.BindingFlags.NonPublic | System.Reflection.BindingFlags.Static)!
            .Invoke(null, new object?[] { args })!;
}
```

---

## `src/LimboDancer.MCP.Cli/Commands/DbMigrateCommand.cs`

```csharp
using System.CommandLine;
using LimboDancer.MCP.Audit;
using LimboDancer.MCP.Storage;
using Microsoft.EntityFrameworkCore;
using Microsoft.Extensions.DependencyInjection;
using Microsoft.Extensions.Hosting;

namespace LimboDancer.MCP.Cli.Commands;

internal static class DbMigrateCommand
{
    public static Command Build()
    {
        var cmd = new Command("db", "Database utilities");

        var migrate = new Command("migrate", "Apply EF Core migrations for Chat & Audit stores");
        migrate.SetHandler(async () =>
        {
            using var host = BuildHost(null);

            await using var scope = host.Services.CreateAsyncScope();
            var chat = scope.ServiceProvider.GetRequiredService<ChatDbContext>();
            var audit = scope.ServiceProvider.GetRequiredService<AuditDbContext>();

            Console.WriteLine("Applying ChatDbContext migrations…");
            await chat.Database.MigrateAsync();

            Console.WriteLine("Applying AuditDbContext migrations…");
            await audit.Database.MigrateAsync();

            Console.WriteLine("Done.");
        });

        cmd.AddCommand(migrate);
        return cmd;
    }

    private static IHost BuildHost(string[]? args) => (IHost)typeof(Program).Assembly
        .GetType("Program")!
        .GetMethod("BuildHost", System.Reflection.BindingFlags.NonPublic | System.Reflection.BindingFlags.Static)!
        .Invoke(null, new object?[] { args })!;
}
```

---

## `src/LimboDancer.MCP.Cli/Commands/VectorInitCommand.cs`

```csharp
using System.CommandLine;
using Azure.Search.Documents.Indexes;
using LimboDancer.MCP.Vector.AzureSearch;
using Microsoft.Extensions.Configuration;
using Microsoft.Extensions.DependencyInjection;
using Microsoft.Extensions.Hosting;

namespace LimboDancer.MCP.Cli.Commands;

internal static class VectorInitCommand
{
    public static Command Build()
    {
        var cmd = new Command("vector", "Vector index operations");

        var dimOpt = new Option<int>("--dim", () => 3072, "Embedding dimensions");
        var profileOpt = new Option<string>("--profile", () => SearchIndexBuilder.DefaultVectorProfile, "Vector profile name");
        var indexOpt = new Option<string?>("--index", "Override index name (defaults to config Search:Index or ldm-memory)");
        var init = new Command("init", "Ensure Azure AI Search index exists");
        init.AddOption(dimOpt);
        init.AddOption(profileOpt);
        init.AddOption(indexOpt);

        init.SetHandler(async (int dim, string profile, string? index) =>
        {
            using var host = BuildHost(null);

            var cfg = host.Services.GetRequiredService<IConfiguration>();
            var indexName = index ?? cfg["Search:Index"] ?? SearchIndexBuilder.DefaultIndexName;

            var ic = host.Services.GetRequiredService<SearchIndexClient>();
            await SearchIndexBuilder.EnsureIndexAsync(ic, indexName, embeddingDimensions: dim, vectorProfileName: profile);

            Console.WriteLine($"Index '{indexName}' ensured with dim={dim}, profile={profile}.");
        }, dimOpt, profileOpt, indexOpt);

        cmd.AddCommand(init);
        return cmd;
    }

    private static IHost BuildHost(string[]? args) => (IHost)typeof(Program).Assembly
        .GetType("Program")!
        .GetMethod("BuildHost", System.Reflection.BindingFlags.NonPublic | System.Reflection.BindingFlags.Static)!
        .Invoke(null, new object?[] { args })!;
}
```

---

## `src/LimboDancer.MCP.Cli/Commands/KgPingCommand.cs`

```csharp
using System.CommandLine;
using Gremlin.Net.Driver;
using Microsoft.Extensions.DependencyInjection;
using Microsoft.Extensions.Hosting;

namespace LimboDancer.MCP.Cli.Commands;

internal static class KgPingCommand
{
    public static Command Build()
    {
        var cmd = new Command("kg", "Knowledge graph utilities");

        var ping = new Command("ping", "Ping Cosmos Gremlin by counting any vertex");
        ping.SetHandler(async () =>
        {
            using var host = BuildHost(null);
            var g = host.Services.GetRequiredService<IGremlinClient>();

            var rs = await g.SubmitAsync<long>("g.V().limit(1).count()");
            var count = rs.Count > 0 ? rs[0] : 0;
            Console.WriteLine($"Gremlin OK. Sample vertex count: {count}");
        });

        cmd.AddCommand(ping);
        return cmd;
    }

    private static IHost BuildHost(string[]? args) => (IHost)typeof(Program).Assembly
        .GetType("Program")!
        .GetMethod("BuildHost", System.Reflection.BindingFlags.NonPublic | System.Reflection.BindingFlags.Static)!
        .Invoke(null, new object?[] { args })!;
}
```

---

## `src/LimboDancer.MCP.Cli/Commands/MemAddCommand.cs`

```csharp
using System.CommandLine;
using System.Text;
using Azure;
using Azure.AI.OpenAI;
using Azure.Search.Documents;
using LimboDancer.MCP.Vector.AzureSearch;
using Microsoft.Extensions.Configuration;
using Microsoft.Extensions.DependencyInjection;
using Microsoft.Extensions.Hosting;
using static LimboDancer.MCP.Vector.AzureSearch.VectorStore;

namespace LimboDancer.MCP.Cli.Commands;

internal static class MemAddCommand
{
    public static Command Build()
    {
        var cmd = new Command("mem", "Vector memory operations");

        var add = new Command("add", "Ingest text/file into Azure AI Search (with embeddings)");
        var fileOpt = new Option<string?>("--file", "Path to a text/markdown file to ingest");
        var textOpt = new Option<string?>("--text", "Raw text to ingest (if no --file)");
        var titleOpt = new Option<string?>("--title", () => "CLI Ingest", "Title field");
        var sourceOpt = new Option<string?>("--source", () => "cli", "Source field");
        var classOpt = new Option<string?>("--class", () => "ldm:MemoryItem", "Ontology class");
        var tagsOpt = new Option<string?>("--tags", () => "kind:vector,source:cli", "CSV tags");
        var maxCharsOpt = new Option<int>("--max-chars", () => 1200, "Chunk size (characters)");
        add.AddOption(fileOpt); add.AddOption(textOpt); add.AddOption(titleOpt);
        add.AddOption(sourceOpt); add.AddOption(classOpt); add.AddOption(tagsOpt); add.AddOption(maxCharsOpt);

        add.SetHandler(async (string? file, string? text, string? title, string? source, string? klass, string? tagsCsv, int maxChars) =>
        {
            using var host = BuildHost(null);
            var cfg = host.Services.GetRequiredService<IConfiguration>();
            var search = host.Services.GetRequiredService<SearchClient>();

            var aoaiEndpoint = cfg["OpenAI:Endpoint"];
            var aoaiKey = cfg["OpenAI:ApiKey"];
            var embedModel = cfg["OpenAI:EmbeddingModel"] ?? "text-embedding-3-large";

            var openAI = new OpenAIClient(new Uri(aoaiEndpoint!), new AzureKeyCredential(aoaiKey!));
            async Task<float[]> EmbedAsync(string s)
            {
                var resp = await openAI.GetEmbeddingsAsync(new EmbeddingsOptions(embedModel, new[] { s }));
                return resp.Value.Data[0].Embedding.ToArray();
            }

            var store = new VectorStore(search, EmbedAsync);

            var raw = string.IsNullOrWhiteSpace(file) ? text : await File.ReadAllTextAsync(file!);
            if (string.IsNullOrWhiteSpace(raw)) { Console.Error.WriteLine("Provide --file or --text."); return; }

            var chunks = Chunk(raw, maxChars);
            Console.WriteLine($"Chunks: {chunks.Count}");

            var now = DateTimeOffset.UtcNow;
            var docs = new List<MemoryDoc>();
            for (int i = 0; i < chunks.Count; i++)
            {
                var id = Guid.NewGuid().ToString("N");
                docs.Add(new MemoryDoc
                {
                    Id = id,
                    Title = title,
                    Content = chunks[i],
                    Source = source,
                    Chunk = i,
                    CreatedAt = now,
                    OntologyClass = klass,
                    Uri = $"ldm:MemoryItem#{id}",
                    Tags = (tagsCsv ?? "").Split(',', StringSplitOptions.RemoveEmptyEntries | StringSplitOptions.TrimEntries)
                });
            }

            await store.UpsertAsync(docs, embedIfMissing: true);
            Console.WriteLine("Upsert complete.");
        }, fileOpt, textOpt, titleOpt, sourceOpt, classOpt, tagsOpt, maxCharsOpt);

        cmd.AddCommand(add);
        return cmd;
    }

    private static List<string> Chunk(string text, int maxChars)
    {
        var parts = SplitSentences(text);
        var chunks = new List<string>();
        var sb = new StringBuilder(maxChars + 128);

        foreach (var s in parts)
        {
            if (sb.Length + s.Length + 1 > maxChars && sb.Length > 0)
            {
                chunks.Add(sb.ToString().Trim());
                sb.Clear();
            }
            sb.AppendLine(s);
        }
        if (sb.Length > 0) chunks.Add(sb.ToString().Trim());
        return chunks;
    }

    private static IEnumerable<string> SplitSentences(string text)
    {
        foreach (var para in text.Split(new[] { "\r\n\r\n", "\n\n" }, StringSplitOptions.RemoveEmptyEntries))
        {
            var p = para.Replace("\r\n", " ").Replace('\n', ' ').Trim();
            if (p.Length == 0) continue;

            var acc = new StringBuilder();
            foreach (var token in p.Split(' '))
            {
                acc.Append(token);
                acc.Append(' ');
                if (token.EndsWith('.') || token.EndsWith('!') || token.EndsWith('?'))
                {
                    yield return acc.ToString().Trim();
                    acc.Clear();
                }
            }
            if (acc.Length > 0) yield return acc.ToString().Trim();
        }
    }

    private static IHost BuildHost(string[]? args) => (IHost)typeof(Program).Assembly
        .GetType("Program")!
        .GetMethod("BuildHost", System.Reflection.BindingFlags.NonPublic | System.Reflection.BindingFlags.Static)!
        .Invoke(null, new object?[] { args })!;
}
```

---

## `src/LimboDancer.MCP.Cli/Commands/MemSearchCommand.cs`

```csharp
using System.CommandLine;
using LimboDancer.MCP.Vector.AzureSearch;
using Microsoft.Extensions.DependencyInjection;
using Microsoft.Extensions.Hosting;

namespace LimboDancer.MCP.Cli.Commands;

internal static class MemSearchCommand
{
    public static Command Build()
    {
        var cmd = new Command("mem", "Vector memory operations");

        var search = new Command("search", "Hybrid search over Azure AI Search");
        var query = new Option<string?>("--query", "BM25/Semantic query text");
        var k = new Option<int>("--k", () => 8, "Top K");
        var klass = new Option<string?>("--class", "Filter: ontologyClass");
        var uriEq = new Option<string?>("--uri", "Filter: URI equals");
        var tags = new Option<string[]>("--tag", description: "Filter: any of these tags", parseArgument: r => r.Tokens.Select(t => t.Value).ToArray());

        search.AddOption(query); search.AddOption(k); search.AddOption(klass); search.AddOption(uriEq); search.AddOption(tags);

        search.SetHandler(async (string? q, int topK, string? oc, string? ue, string[] tagArr) =>
        {
            using var host = BuildHost(null);
            var store = host.Services.GetRequiredService<VectorStore>();

            var filters = new VectorStore.SearchFilters
            {
                OntologyClass = oc,
                UriEquals = ue,
                TagsAny = tagArr?.Length > 0 ? tagArr : null
            };

            var res = await store.SearchHybridAsync(q, vector: null, k: topK, filters: filters);
            foreach (var r in res)
            {
                Console.WriteLine($"[{r.Score:F3}] {r.Title}  {r.Source}#{r.Chunk}  class={r.OntologyClass} tags=[{string.Join(",", r.Tags ?? Array.Empty<string>())}]");
                var prev = r.Content.Length > 180 ? r.Content[..180] + "…" : r.Content;
                Console.WriteLine(prev + "\n");
            }
        }, query, k, klass, uriEq, tags);

        cmd.AddCommand(search);
        return cmd;
    }

    private static IHost BuildHost(string[]? args) => (IHost)typeof(Program).Assembly
        .GetType("Program")!
        .GetMethod("BuildHost", System.Reflection.BindingFlags.NonPublic | System.Reflection.BindingFlags.Static)!
        .Invoke(null, new object?[] { args })!;
}
```

---

## `docs/DEVSETUP.md`

````markdown
# Dev Setup — LimboDancer.MCP

This quickstart gets your local stack running with Postgres, Azure AI Search, Cosmos Gremlin (or emulator), and the developer CLI.

## Prereqs

- .NET 9 SDK
- Docker (for local Postgres)
- Azure subscription with:
  - **Azure AI Search** (Standard or above)
  - **Azure OpenAI** (for embeddings)
  - **Azure Cosmos DB (Gremlin)** or Gremlin Emulator
- (Optional) Node/Browser to consume SSE from the HTTP host

## 1) Postgres

```bash
docker run --name pg-limbo -e POSTGRES_PASSWORD=postgres -p 5432:5432 -d postgres:16
````

Create dev DBs if you like, or let EF create tables on first migration.

## 2) Configure `appsettings.Development.json`

Copy this to `src/LimboDancer.MCP.Cli/appsettings.Development.json` (and to the HTTP/Blazor projects if needed) and fill values:

```json
{
  "Persistence": {
    "ConnectionString": "Host=localhost;Port=5432;Database=limbodancer_dev;Username=postgres;Password=postgres"
  },
  "Audit": {
    "ConnectionString": "Host=localhost;Port=5432;Database=limbodancer_audit;Username=postgres;Password=postgres"
  },
  "Search": {
    "Endpoint": "https://<search>.search.windows.net",
    "ApiKey": "<key>",
    "Index": "ldm-memory"
  },
  "OpenAI": {
    "Endpoint": "https://<aoai>.openai.azure.com",
    "ApiKey": "<key>",
    "EmbeddingModel": "text-embedding-3-large"
  },
  "Gremlin": {
    "Host": "<acct>.gremlin.cosmos.azure.com",
    "Port": "443",
    "Database": "ldm",
    "Graph": "kg",
    "Key": "<primary-key>"
  }
}
```

> If using the **Gremlin Emulator**, set `Host=localhost`, `Port=8901`, and use the emulator key.

## 3) First run

```bash
# From repo root
dotnet build

# Apply migrations (Chat + Audit)
dotnet run --project src/LimboDancer.MCP.Cli -- db migrate

# Ensure the Azure AI Search index
dotnet run --project src/LimboDancer.MCP.Cli -- vector init --dim 3072

# Sanity check Gremlin
dotnet run --project src/LimboDancer.MCP.Cli -- kg ping
```

## 4) Ingest + search (dev loop)

```bash
# Add memory from a file
dotnet run --project src/LimboDancer.MCP.Cli -- mem add --file ./docs/travel-policy.md --title "Travel Policy" --source docs

# Or ad-hoc text
dotnet run --project src/LimboDancer.MCP.Cli -- mem add --text "Hello world. This is a test." --tags "demo,hello"

# Search
dotnet run --project src/LimboDancer.MCP.Cli -- mem search --query "baggage" --k 5 --class "ldm:MemoryItem" --tag "domain:travel"
```

## 5) Stdio server

The CLI includes a **stub** for `serve --stdio`. Wire this to your MCP stdio host once your `McpServer` exposes a runner, e.g.:

```csharp
// in ServeCommand.cs
var runner = host.Services.GetRequiredService<McpStdioRunner>();
await runner.RunAsync();
```

## 6) Troubleshooting

* **Search 403**: Ensure the API key has admin permissions; check the index name.
* **Gremlin timeouts**: Verify port/SSL settings, and that DB/Graph names exist.
* **Embeddings**: Make sure the AOAI resource has the embedding deployment you referenced.

````

---

## `src/LimboDancer.MCP.Cli/appsettings.Development.json`

```json
{
  "Persistence": {
    "ConnectionString": "Host=localhost;Port=5432;Database=limbodancer_dev;Username=postgres;Password=postgres"
  },
  "Audit": {
    "ConnectionString": "Host=localhost;Port=5432;Database=limbodancer_audit;Username=postgres;Password=postgres"
  },
  "Search": {
    "Endpoint": "https://<search>.search.windows.net",
    "ApiKey": "<key>",
    "Index": "ldm-memory"
  },
  "OpenAI": {
    "Endpoint": "https://<aoai>.openai.azure.com",
    "ApiKey": "<key>",
    "EmbeddingModel": "text-embedding-3-large"
  },
  "Gremlin": {
    "Host": "localhost",
    "Port": "8901",
    "Database": "ldm",
    "Graph": "kg",
    "Key": "<emulator-or-account-key>"
  }
}
````

---

### Notes / Next steps

* The **stdio server** is intentionally a stub so you can plug in the actual MCP SDK runner you’re using.
* If you’d like, I can also add a `LimboDancer.MCP.Cli.csproj` with NuGet references (`System.CommandLine`, `Azure.Search.Documents`, `Azure.AI.OpenAI`, `Gremlin.Net`, `Microsoft.EntityFrameworkCore.Design`, etc.) and a small **`dotnet tool`** manifest to install the CLI globally.
