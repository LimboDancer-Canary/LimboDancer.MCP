**PR‑2** — Azure AI Search vector layer with a BM25 + vectors index, an index builder, a simple vector store, and a smoke test that uses random embeddings.

---

# Project layout

```
src/
  LimboDancer.MCP.Vector.AzureSearch/
    LimboDancer.MCP.Vector.AzureSearch.csproj
    Models/MemoryDoc.cs
    SearchIndexBuilder.cs
    VectorStore.cs
tests/
  LimboDancer.MCP.Vector.AzureSearch.Tests/
    LimboDancer.MCP.Vector.AzureSearch.Tests.csproj
    VectorStoreSmokeTests.cs
```

---

## src/LimboDancer.MCP.Vector.AzureSearch/LimboDancer.MCP.Vector.AzureSearch.csproj

```xml
<Project Sdk="Microsoft.NET.Sdk">
  <PropertyGroup>
    <TargetFramework>net9.0</TargetFramework>
    <Nullable>enable</Nullable>
    <ImplicitUsings>enable</ImplicitUsings>
  </PropertyGroup>

  <ItemGroup>
    <PackageReference Include="Azure.Search.Documents" Version="11.6.1" />
  </ItemGroup>
</Project>
```

## src/LimboDancer.MCP.Vector.AzureSearch/Models/MemoryDoc.cs

```csharp
using System.Text.Json.Serialization;

namespace LimboDancer.MCP.Vector.AzureSearch;

/// <summary>
/// Minimal document shape for vector indexing & search.
/// </summary>
public sealed class MemoryDoc
{
    [JsonPropertyName("id")]
    public string Id { get; set; } = default!;

    [JsonPropertyName("content")]
    public string Content { get; set; } = string.Empty;

    [JsonPropertyName("tags")]
    public string[]? Tags { get; set; }

    [JsonPropertyName("externalId")]
    public string? ExternalId { get; set; }

    /// <summary>Optional precomputed embedding. If null and an embedder is provided, it will be filled on upsert.</summary>
    [JsonPropertyName("vector")]
    public float[]? Vector { get; set; }
}
```

## src/LimboDancer.MCP.Vector.AzureSearch/SearchIndexBuilder.cs

```csharp
using Azure;
using Azure.Search.Documents.Indexes;
using Azure.Search.Documents.Indexes.Models;
using Azure.Search.Documents.Models;

namespace LimboDancer.MCP.Vector.AzureSearch;

public sealed class SearchIndexBuilder
{
    public const string VectorFieldName = "vector";
    public const string ContentFieldName = "content";
    public const string TagsFieldName = "tags";
    public const string ExternalIdFieldName = "externalId";
    public const string KeyFieldName = "id";

    // Names for vector configuration
    private const string HnswAlgoName = "hnsw-default";
    private const string VectorProfileName = "vector-profile";

    private readonly SearchIndexClient _indexClient;

    public SearchIndexBuilder(Uri endpoint, string apiKey)
    {
        _indexClient = new SearchIndexClient(endpoint, new AzureKeyCredential(apiKey));
    }

    public SearchIndexBuilder(SearchIndexClient indexClient) => _indexClient = indexClient;

    /// <summary>Create or update an index with BM25 + vector field.</summary>
    public async Task EnsureIndexAsync(string indexName, int vectorDimensions, CancellationToken ct = default)
    {
        var fields = new List<SearchField>
        {
            new SimpleField(KeyFieldName, SearchFieldDataType.String) { IsKey = true, IsFilterable = true },
            new SearchField(ContentFieldName, SearchFieldDataType.String) { IsSearchable = true },
            new SearchField(TagsFieldName, SearchFieldDataType.Collection(SearchFieldDataType.String)) { IsFilterable = true, IsFacetable = true },
            new SearchField(ExternalIdFieldName, SearchFieldDataType.String) { IsFilterable = true }
        };

        // Vector field: Collection(Single), with profile & dimensions
        fields.Add(new SearchField(VectorFieldName, SearchFieldDataType.Collection(SearchFieldDataType.Single))
        {
            // Vector-specific settings (GA API)
            VectorSearchDimensions = vectorDimensions,
            VectorSearchProfileName = VectorProfileName,
            // vectors are not searchable text; do not mark IsSearchable
            // IsStored defaults true for vectors (retrievable); leave as default
        });

        var index = new SearchIndex(indexName)
        {
            Fields = fields,
            Similarity = new BM25Similarity(), // BM25 for keyword portion
            VectorSearch = new VectorSearch
            {
                Algorithms =
                {
                    new HnswAlgorithmConfiguration(HnswAlgoName)
                    {
                        Parameters = new HnswParameters
                        {
                            // Sensible defaults; tune later as needed
                            M = 16,
                            EfConstruction = 400,
                            EfSearch = 100
                        }
                    }
                },
                Profiles =
                {
                    new VectorSearchProfile(VectorProfileName, HnswAlgoName)
                }
            }
        };

        // Create or update
        await _indexClient.CreateOrUpdateIndexAsync(index, ct);
    }
}
```

## src/LimboDancer.MCP.Vector.AzureSearch/VectorStore.cs

```csharp
using Azure;
using Azure.Search.Documents;
using Azure.Search.Documents.Indexes;
using Azure.Search.Documents.Models;

namespace LimboDancer.MCP.Vector.AzureSearch;

/// <summary>
/// Thin vector store over Azure AI Search with hybrid search.
/// </summary>
public sealed class VectorStore
{
    private readonly SearchClient _search;
    private readonly SearchIndexBuilder _builder;
    private readonly string _indexName;
    private readonly int _dims;

    public VectorStore(Uri endpoint, string apiKey, string indexName, int vectorDimensions)
    {
        _indexName = indexName;
        _dims = vectorDimensions;

        var indexClient = new SearchIndexClient(endpoint, new AzureKeyCredential(apiKey));
        _builder = new SearchIndexBuilder(indexClient);

        _search = new SearchClient(endpoint, indexName, new AzureKeyCredential(apiKey));
    }

    /// <summary>
    /// Ensures the index exists with the right schema.
    /// </summary>
    public Task EnsureIndexAsync(CancellationToken ct = default) =>
        _builder.EnsureIndexAsync(_indexName, _dims, ct);

    /// <summary>
    /// Upsert documents. If a document has no <see cref="MemoryDoc.Vector"/> and an embedder is provided,
    /// the embedder will be invoked to populate it.
    /// </summary>
    /// <param name="docs">Documents to upsert.</param>
    /// <param name="embedIfMissing">If true and embedder provided, fill missing vectors.</param>
    /// <param name="embedder">Delegate that returns a vector for the input text (usually doc.Content).</param>
    public async Task UpsertAsync(IEnumerable<MemoryDoc> docs,
                                  bool embedIfMissing = true,
                                  Func<MemoryDoc, Task<float[]>>? embedder = null,
                                  CancellationToken ct = default)
    {
        var list = new List<MemoryDoc>();
        foreach (var d in docs)
        {
            if (d.Vector is null && embedIfMissing && embedder is not null)
            {
                d.Vector = await embedder(d);
            }
            if (d.Vector is null)
                throw new InvalidOperationException($"Doc {d.Id} has no vector and no embedder was provided.");

            if (d.Vector.Length != _dims)
                throw new InvalidOperationException($"Doc {d.Id} vector has length {d.Vector.Length}, expected {_dims}.");

            list.Add(d);
        }

        // Merge or upload
        await _search.MergeOrUploadDocumentsAsync(list, cancellationToken: ct);
    }

    public sealed record SearchHit(MemoryDoc Doc, double Score);

    /// <summary>
    /// Hybrid search (text + optional vector). If vector is null, it's standard keyword search.
    /// </summary>
    public async Task<IReadOnlyList<SearchHit>> SearchHybridAsync(
        string? queryText,
        float[]? vector,
        int k = 5,
        string? filterOData = null,
        CancellationToken ct = default)
    {
        var options = new SearchOptions
        {
            Size = k,
            IncludeTotalCount = false
        };

        // Return the core fields; vectors usually aren't useful to retrieve
        options.Select.AddRange(new[] { "id", "content", "tags", "externalId" });

        // Scope the full-text search
        options.SearchFields.AddRange(new[] { "content", "tags", "externalId" });

        if (!string.IsNullOrWhiteSpace(filterOData))
            options.Filter = filterOData;

        // Attach vector part if provided
        if (vector is not null)
        {
            if (vector.Length != _dims)
                throw new InvalidOperationException($"Query vector length {vector.Length} != {_dims}.");

            var vq = new VectorizedQuery(vector)
            {
                KNearestNeighborsCount = k
            };
            vq.Fields.Add(SearchIndexBuilder.VectorFieldName);

            options.VectorSearch = new VectorSearchOptions();
            options.VectorSearch.Queries.Add(vq);
        }

        // For pure vector search you can pass empty string; for hybrid, pass the query text.
        var text = queryText ?? string.Empty;
        var resp = await _search.SearchAsync<SearchDocument>(text, options, ct);

        var results = new List<SearchHit>();
        await foreach (var r in resp.Value.GetResultsAsync())
        {
            var doc = new MemoryDoc
            {
                Id = (string)r.Document["id"],
                Content = r.Document.TryGetValue("content", out var c) ? c?.ToString() ?? "" : "",
                ExternalId = r.Document.TryGetValue("externalId", out var e) ? e?.ToString() : null,
                Tags = r.Document.TryGetValue("tags", out var t) ? (t as IEnumerable<object>)?.Select(o => o.ToString()!).ToArray() : null
            };
            results.Add(new SearchHit(doc, r.Score ?? 0));
        }
        return results;
    }
}
```

---

## tests/LimboDancer.MCP.Vector.AzureSearch.Tests/LimboDancer.MCP.Vector.AzureSearch.Tests.csproj

```xml
<Project Sdk="Microsoft.NET.Sdk">
  <PropertyGroup>
    <TargetFramework>net9.0</TargetFramework>
    <Nullable>enable</Nullable>
    <ImplicitUsings>enable</ImplicitUsings>
  </PropertyGroup>

  <ItemGroup>
    <PackageReference Include="xunit" Version="2.7.0" />
    <PackageReference Include="xunit.runner.visualstudio" Version="2.5.7">
      <PrivateAssets>all</PrivateAssets>
    </PackageReference>
    <PackageReference Include="FluentAssertions" Version="6.12.0" />
    <PackageReference Include="Azure.Search.Documents" Version="11.6.1" />
  </ItemGroup>

  <ItemGroup>
    <ProjectReference Include="..\..\src\LimboDancer.MCP.Vector.AzureSearch\LimboDancer.MCP.Vector.AzureSearch.csproj" />
  </ItemGroup>
</Project>
```

## tests/LimboDancer.MCP.Vector.AzureSearch.Tests/VectorStoreSmokeTests.cs

```csharp
using System.Security.Cryptography;
using FluentAssertions;
using LimboDancer.MCP.Vector.AzureSearch;

public class VectorStoreSmokeTests
{
    // Set these in your environment to run against a live service.
    private static readonly string? Endpoint = Environment.GetEnvironmentVariable("AZURE_SEARCH_ENDPOINT");
    private static readonly string? ApiKey   = Environment.GetEnvironmentVariable("AZURE_SEARCH_API_KEY");

    // Keep this small for a fast/randomized smoke run
    private const int Dims = 32;

    private static bool Configured => !string.IsNullOrWhiteSpace(Endpoint) && !string.IsNullOrWhiteSpace(ApiKey);

    private static float[] DeterministicRandomVector(string seed, int dims)
    {
        // Deterministic pseudo-random per seed for stability across runs
        var hash = SHA256.HashData(System.Text.Encoding.UTF8.GetBytes(seed));
        var r = new Random(BitConverter.ToInt32(hash, 0));
        var v = new float[dims];
        for (int i = 0; i < dims; i++)
            v[i] = (float)(r.NextDouble() * 2.0 - 1.0); // [-1, 1]
        return v;
    }

    [Fact(Skip = "Set AZURE_SEARCH_ENDPOINT and AZURE_SEARCH_API_KEY to run this smoke test against your service.")]
    public async Task HybridSearch_Returns_UpsertedDocs()
    {
        if (!Configured)
            return;

        var endpoint = new Uri(Endpoint!);
        var indexName = "ldmcp-smoke-" + Guid.NewGuid().ToString("N").Substring(0, 6);
        var store = new VectorStore(endpoint, ApiKey!, indexName, Dims);

        await store.EnsureIndexAsync();

        var docs = new[]
        {
            new MemoryDoc { Id = "1", Content = "The quick brown fox jumps over the lazy dog", Tags = new[] {"animal","pangram"}, ExternalId = "fox-1", Vector = DeterministicRandomVector("1", Dims) },
            new MemoryDoc { Id = "2", Content = "Azure AI Search supports hybrid search with BM25 and vector similarity", Tags = new[] {"azure","search"}, ExternalId = "doc-2", Vector = DeterministicRandomVector("2", Dims) }
        };

        // Upsert with existing vectors (delegate not needed for this smoke)
        await store.UpsertAsync(docs, embedIfMissing: false);

        // Small retry loop to allow near‑real‑time commit
        IReadOnlyList<VectorStore.SearchHit>? hits = null;
        for (int attempt = 0; attempt < 10; attempt++)
        {
            hits = await store.SearchHybridAsync(
                queryText: "hybrid search vector BM25 brown fox", // text will match both docs
                vector: DeterministicRandomVector("query", Dims),  // random vector part (still hybrid)
                k: 5);

            if (hits.Count >= 2) break;
            await Task.Delay(500);
        }

        hits.Should().NotBeNull();
        hits!.Select(h => h.Doc.Id).Should().Contain(new[] { "1", "2" });
    }
}
```

---

## Smoke test (quick start)

1. Create your search service & get the **endpoint** and **admin key**.

2. Export env vars:

```bash
# e.g. PowerShell
$env:AZURE_SEARCH_ENDPOINT="https://<your-service>.search.windows.net"
$env:AZURE_SEARCH_API_KEY="<admin-key>"
```

3. Run tests (the smoke test is skipped by default; enable by removing the `[Skip]` or running locally and editing the attribute):

```bash
dotnet test tests/LimboDancer.MCP.Vector.AzureSearch.Tests
```

Or drop a tiny console to call:

```csharp
// Pseudocode:
// var store = new VectorStore(new Uri(endpoint), apiKey, "ldmcp-demo", 32);
// await store.EnsureIndexAsync();
// await store.UpsertAsync(new[]{ /* two MemoryDoc with random vectors */ }, embedIfMissing:false);
// var results = await store.SearchHybridAsync("brown fox", DeterministicRandomVector("query",32), 5);
// Console.WriteLine(string.Join("\n", results.Select(r => $"{r.Score:F3} {r.Doc.Id} {r.Doc.Content}")));
```

---

### Notes / alignments

* Uses **GA SDK & API**: vector field via `SearchField.VectorSearchDimensions` and `VectorSearchProfileName`, HNSW profile, and hybrid queries via `SearchOptions.VectorSearch.Queries` of type `VectorizedQuery` (Azure SDK docs: vector queries & hybrid searches ([Microsoft Learn][1])).
* BM25 is the default keyword ranking; we set it explicitly on the index (SDK `BM25Similarity`) and run hybrid (RRF) when both text and vectors are present (hybrid overview & behavior ([Microsoft Learn][2])).

If you want me to wire this behind an interface (e.g., `IVectorStore`) and add DI sugar/Options next, I can make that **PR‑3**.

[1]: https://learn.microsoft.com/en-us/dotnet/api/azure.search.documents.models.vectorquery?view=azure-dotnet "VectorQuery Class (Azure.Search.Documents.Models) - Azure for .NET Developers | Microsoft Learn"
[2]: https://learn.microsoft.com/en-us/azure/search/hybrid-search-how-to-query?utm_source=chatgpt.com "Create a hybrid query in Azure AI Search"
