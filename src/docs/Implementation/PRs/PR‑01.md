Let’s knock out **PR‑1**. Below are **ready‑to‑drop files** (full contents) matching your spec. They create two projects (`Core`, `Storage`) with EF Core + Postgres, plus a tiny xUnit test to prove the flow (create → append x2 → read=2). I’ve also included the migration smoke‑test steps.

---

# Project layout

```
src/
  LimboDancer.MCP.Core/
    LimboDancer.MCP.Core.csproj
    Abstractions/IChatHistoryStore.cs
    Errors/DomainException.cs
    Primitives/Result.cs
  LimboDancer.MCP.Storage/
    LimboDancer.MCP.Storage.csproj
    Entities.cs
    ChatDbContext.cs
    Repositories/ChatHistoryStore.cs
    StorageOptions.cs
    ServiceCollectionExtensions.cs
tests/
  LimboDancer.MCP.Storage.Tests/
    LimboDancer.MCP.Storage.Tests.csproj
    ChatHistoryStoreTests.cs
```

---

## src/LimboDancer.MCP.Core/LimboDancer.MCP.Core.csproj

```xml
<Project Sdk="Microsoft.NET.Sdk">
  <PropertyGroup>
    <TargetFramework>net9.0</TargetFramework>
    <Nullable>enable</Nullable>
    <ImplicitUsings>enable</ImplicitUsings>
  </PropertyGroup>
</Project>
```

## src/LimboDancer.MCP.Core/Abstractions/IChatHistoryStore.cs

```csharp
using System.Text.Json;
using LimboDancer.MCP.Storage;

namespace LimboDancer.MCP.Core;

public interface IChatHistoryStore
{
    Task<Session> CreateSessionAsync(string userId, JsonDocument? tagsJson = null, CancellationToken ct = default);
    Task<Message> AppendMessageAsync(Guid sessionId, MessageRole role, string content, JsonDocument? toolCallsJson = null, CancellationToken ct = default);
    Task<IReadOnlyList<Message>> GetMessagesAsync(Guid sessionId, int take = 100, int skip = 0, CancellationToken ct = default);
}
```

## src/LimboDancer.MCP.Core/Errors/DomainException.cs

```csharp
namespace LimboDancer.MCP.Core;

public sealed class DomainException : Exception
{
    public string Code { get; }

    public DomainException(string code, string message) : base(message) => Code = code;

    public static DomainException NotFound(string what) => new("not_found", $"{what} not found.");
    public static DomainException Invalid(string what) => new("invalid", $"{what} is invalid.");
}
```

## src/LimboDancer.MCP.Core/Primitives/Result.cs

```csharp
namespace LimboDancer.MCP.Core;

public readonly struct Result<T>
{
    public bool Success { get; }
    public T? Value { get; }
    public string? Error { get; }

    private Result(bool success, T? value, string? error)
    { Success = success; Value = value; Error = error; }

    public static Result<T> Ok(T value) => new(true, value, null);
    public static Result<T> Fail(string error) => new(false, default, error);
}
```

---

## src/LimboDancer.MCP.Storage/LimboDancer.MCP.Storage.csproj

```xml
<Project Sdk="Microsoft.NET.Sdk">
  <PropertyGroup>
    <TargetFramework>net9.0</TargetFramework>
    <Nullable>enable</Nullable>
    <ImplicitUsings>enable</ImplicitUsings>
  </PropertyGroup>

  <ItemGroup>
    <PackageReference Include="Microsoft.EntityFrameworkCore" Version="9.0.0" />
    <PackageReference Include="Microsoft.EntityFrameworkCore.Relational" Version="9.0.0" />
    <PackageReference Include="Npgsql.EntityFrameworkCore.PostgreSQL" Version="9.0.0" />
    <PackageReference Include="Microsoft.Extensions.Options.ConfigurationExtensions" Version="9.0.0" />
    <!-- EF design-time tooling for dotnet-ef -->
    <PackageReference Include="Microsoft.EntityFrameworkCore.Design" Version="9.0.0">
      <PrivateAssets>all</PrivateAssets>
    </PackageReference>
  </ItemGroup>

  <ItemGroup>
    <ProjectReference Include="..\LimboDancer.MCP.Core\LimboDancer.MCP.Core.csproj" />
  </ItemGroup>
</Project>
```

## src/LimboDancer.MCP.Storage/Entities.cs

```csharp
using System.Text.Json;

namespace LimboDancer.MCP.Storage;

public sealed class Session
{
    public Guid Id { get; set; }
    public string UserId { get; set; } = null!;
    public JsonDocument? TagsJson { get; set; }
    public DateTime CreatedAt { get; set; }
    public ICollection<Message> Messages { get; set; } = new List<Message>();
}

public enum MessageRole { User, Assistant, Tool }

public sealed class Message
{
    public Guid Id { get; set; }
    public Guid SessionId { get; set; }
    public MessageRole Role { get; set; }
    public string Content { get; set; } = string.Empty;
    public JsonDocument? ToolCallsJson { get; set; }
    public DateTime CreatedAt { get; set; }
    public Session Session { get; set; } = null!;
}

public enum MemoryKind { Vector, Graph, Reasoning }

public sealed class MemoryItem
{
    public Guid Id { get; set; }
    public MemoryKind Kind { get; set; }
    public string ExternalId { get; set; } = "";
    public JsonDocument? MetaJson { get; set; }
    public DateTime CreatedAt { get; set; }
}
```

## src/LimboDancer.MCP.Storage/ChatDbContext.cs

```csharp
using Microsoft.EntityFrameworkCore;

namespace LimboDancer.MCP.Storage;

public sealed class ChatDbContext : DbContext
{
    public DbSet<Session> Sessions => Set<Session>();
    public DbSet<Message> Messages => Set<Message>();
    public DbSet<MemoryItem> MemoryItems => Set<MemoryItem>();

    public ChatDbContext(DbContextOptions<ChatDbContext> options) : base(options) {}

    protected override void OnModelCreating(ModelBuilder b)
    {
        // Session
        b.Entity<Session>(e =>
        {
            e.ToTable("sessions");
            e.HasKey(x => x.Id);
            e.Property(x => x.Id).ValueGeneratedNever();
            e.Property(x => x.UserId).HasMaxLength(256).IsRequired();
            e.Property(x => x.TagsJson).HasColumnType("jsonb");
            e.Property(x => x.CreatedAt).HasColumnType("timestamptz")
              .HasDefaultValueSql("now() at time zone 'utc'");
            e.HasIndex(x => x.CreatedAt);
            e.HasMany(x => x.Messages).WithOne(m => m.Session).HasForeignKey(m => m.SessionId);
        });

        // Message
        b.Entity<Message>(e =>
        {
            e.ToTable("messages");
            e.HasKey(x => x.Id);
            e.Property(x => x.Id).ValueGeneratedNever();
            e.Property(x => x.Content).HasColumnType("text").IsRequired();
            e.Property(x => x.ToolCallsJson).HasColumnType("jsonb");
            e.Property(x => x.CreatedAt).HasColumnType("timestamptz")
              .HasDefaultValueSql("now() at time zone 'utc'");
            e.HasIndex(x => new { x.SessionId, x.CreatedAt });
            e.HasIndex(x => x.Role);
        });

        // MemoryItem
        b.Entity<MemoryItem>(e =>
        {
            e.ToTable("memory_items");
            e.HasKey(x => x.Id);
            e.Property(x => x.Id).ValueGeneratedNever();
            e.Property(x => x.ExternalId).HasMaxLength(256).IsRequired();
            e.Property(x => x.MetaJson).HasColumnType("jsonb");
            e.Property(x => x.CreatedAt).HasColumnType("timestamptz")
              .HasDefaultValueSql("now() at time zone 'utc'");
            e.HasIndex(x => new { x.Kind, x.CreatedAt });
            e.HasIndex(x => new { x.Kind, x.ExternalId });
        });
    }
}
```

## src/LimboDancer.MCP.Storage/Repositories/ChatHistoryStore.cs

```csharp
using System.Text.Json;
using LimboDancer.MCP.Core;
using Microsoft.EntityFrameworkCore;

namespace LimboDancer.MCP.Storage;

public sealed class ChatHistoryStore : IChatHistoryStore
{
    private readonly ChatDbContext _db;

    public ChatHistoryStore(ChatDbContext db) => _db = db;

    public async Task<Session> CreateSessionAsync(string userId, JsonDocument? tagsJson = null, CancellationToken ct = default)
    {
        var s = new Session
        {
            Id = Guid.NewGuid(),
            UserId = userId,
            TagsJson = tagsJson,
            CreatedAt = DateTime.UtcNow
        };
        _db.Sessions.Add(s);
        await _db.SaveChangesAsync(ct);
        return s;
    }

    public async Task<Message> AppendMessageAsync(Guid sessionId, MessageRole role, string content, JsonDocument? toolCallsJson = null, CancellationToken ct = default)
    {
        var exists = await _db.Sessions.AsNoTracking().AnyAsync(x => x.Id == sessionId, ct);
        if (!exists) throw DomainException.NotFound($"Session {sessionId}");

        var m = new Message
        {
            Id = Guid.NewGuid(),
            SessionId = sessionId,
            Role = role,
            Content = content,
            ToolCallsJson = toolCallsJson,
            CreatedAt = DateTime.UtcNow
        };
        _db.Messages.Add(m);
        await _db.SaveChangesAsync(ct);
        return m;
    }

    public async Task<IReadOnlyList<Message>> GetMessagesAsync(Guid sessionId, int take = 100, int skip = 0, CancellationToken ct = default)
    {
        take = Math.Clamp(take, 1, 1000);
        skip = Math.Max(0, skip);

        var items = await _db.Messages.AsNoTracking()
            .Where(x => x.SessionId == sessionId)
            .OrderBy(x => x.CreatedAt)
            .Skip(skip)
            .Take(take)
            .ToListAsync(ct);

        return items;
    }
}
```

## src/LimboDancer.MCP.Storage/StorageOptions.cs

```csharp
namespace LimboDancer.MCP.Storage;

public sealed class StorageOptions
{
    public string ConnectionString { get; set; } = "";
    public bool ApplyMigrationsAtStartup { get; set; } = false;
}
```

## src/LimboDancer.MCP.Storage/ServiceCollectionExtensions.cs

```csharp
using Microsoft.EntityFrameworkCore;
using Microsoft.Extensions.Configuration;
using Microsoft.Extensions.DependencyInjection;
using Microsoft.Extensions.Hosting;

namespace LimboDancer.MCP.Storage;

public static class ServiceCollectionExtensions
{
    public static IServiceCollection AddPersistence(this IServiceCollection services, IConfiguration config)
    {
        var section = config.GetSection("Persistence");
        services.Configure<StorageOptions>(section);
        var opts = section.Get<StorageOptions>() ?? new();

        services.AddDbContext<ChatDbContext>(db =>
        {
            db.UseNpgsql(opts.ConnectionString);
        });

        services.AddScoped<IChatHistoryStore, ChatHistoryStore>();
        return services;
    }

    public static async Task InitializePersistenceAsync(this IServiceProvider sp, CancellationToken ct = default)
    {
        using var scope = sp.CreateScope();
        var ctx = scope.ServiceProvider.GetRequiredService<ChatDbContext>();
        var opts = scope.ServiceProvider.GetRequiredService<Microsoft.Extensions.Options.IOptions<StorageOptions>>().Value;

        if (opts.ApplyMigrationsAtStartup)
            await ctx.Database.MigrateAsync(ct);

        await ctx.Database.CanConnectAsync(ct);
    }
}
```

---

## tests/LimboDancer.MCP.Storage.Tests/LimboDancer.MCP.Storage.Tests.csproj

```xml
<Project Sdk="Microsoft.NET.Sdk">
  <PropertyGroup>
    <TargetFramework>net9.0</TargetFramework>
    <Nullable>enable</Nullable>
    <ImplicitUsings>enable</ImplicitUsings>
  </PropertyGroup>

  <ItemGroup>
    <PackageReference Include="Microsoft.EntityFrameworkCore.InMemory" Version="9.0.0" />
    <PackageReference Include="xunit" Version="2.7.0" />
    <PackageReference Include="xunit.runner.visualstudio" Version="2.5.7">
      <PrivateAssets>all</PrivateAssets>
    </PackageReference>
    <PackageReference Include="FluentAssertions" Version="6.12.0" />
  </ItemGroup>

  <ItemGroup>
    <ProjectReference Include="..\..\src\LimboDancer.MCP.Core\LimboDancer.MCP.Core.csproj" />
    <ProjectReference Include="..\..\src\LimboDancer.MCP.Storage\LimboDancer.MCP.Storage.csproj" />
  </ItemGroup>
</Project>
```

## tests/LimboDancer.MCP.Storage.Tests/ChatHistoryStoreTests.cs

```csharp
using FluentAssertions;
using LimboDancer.MCP.Core;
using LimboDancer.MCP.Storage;
using Microsoft.EntityFrameworkCore;

public class ChatHistoryStoreTests
{
    private static ChatHistoryStore MakeSut(string dbName)
    {
        var opts = new DbContextOptionsBuilder<ChatDbContext>()
            .UseInMemoryDatabase(databaseName: dbName)
            .Options;
        var ctx = new ChatDbContext(opts);
        return new ChatHistoryStore(ctx);
    }

    [Fact]
    public async Task CreateAppendRead_Roundtrip_Works()
    {
        var sut = MakeSut(nameof(CreateAppendRead_Roundtrip_Works));

        var session = await sut.CreateSessionAsync("u1");
        var m1 = await sut.AppendMessageAsync(session.Id, MessageRole.User, "hello");
        var m2 = await sut.AppendMessageAsync(session.Id, MessageRole.Assistant, "hi!");

        var back = await sut.GetMessagesAsync(session.Id, take: 10);
        back.Should().HaveCount(2);
        back[0].Content.Should().Be("hello");
        back[1].Content.Should().Be("hi!");
    }
}
```

---

# App settings (example)

Wherever you host the HTTP server (e.g., `src/LimboDancer.MCP.McpServer.Http/appsettings.Development.json`), add:

```json
{
  "Persistence": {
    "ConnectionString": "Host=localhost;Port=5432;Database=limbodancer_dev;Username=postgres;Password=postgres",
    "ApplyMigrationsAtStartup": false
  }
}
```

---

# Smoke test

From the repo root (with **PostgreSQL** reachable locally):

```bash
# 1) Add EF tools if needed:
dotnet tool update --global dotnet-ef

# 2) Create the initial migration in the Storage project:
dotnet ef migrations add Init \
  --project src/LimboDancer.MCP.Storage/LimboDancer.MCP.Storage.csproj \
  --startup-project src/LimboDancer.MCP.Storage/LimboDancer.MCP.Storage.csproj

# 3) Apply it to your dev DB:
dotnet ef database update \
  --project src/LimboDancer.MCP.Storage/LimboDancer.MCP.Storage.csproj \
  --startup-project src/LimboDancer.MCP.Storage/LimboDancer.MCP.Storage.csproj
```

> If you prefer applying at runtime, set `"ApplyMigrationsAtStartup": true` and call `await services.InitializePersistenceAsync()` on boot.

---

# What you get

* **Core contracts** (`IChatHistoryStore`) + simple **Result/Exception** primitives.
* **EF Core Postgres** models (`Session`, `Message`, `MemoryItem`), `ChatDbContext`.
* **Storage DI** (`AddPersistence`) and **repository** (`ChatHistoryStore`) with `create → append → read`.
* **Unit test** proving the happy path.
* **EF migrations** ready via `dotnet ef` commands above.

If you want me to also wire this into your **CLI** (`db migrate`) and **Operator Console** later, say the word and I’ll roll those changes into PR‑2.
