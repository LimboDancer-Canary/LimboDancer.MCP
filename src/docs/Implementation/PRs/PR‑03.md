**PR‑3 (Cosmos Gremlin graph layer)** with complete, drop‑in files, matching your folder convention (tests under `src/Tests/...`).

---

# Project layout

```
src/
  LimboDancer.MCP.Graph.CosmosGremlin/
    LimboDancer.MCP.Graph.CosmosGremlin.csproj
    GremlinOptions.cs
    GremlinClientFactory.cs
    GraphWriteHelpers.cs
src/Tests/
  LimboDancer.MCP.Graph.CosmosGremlin.Tests/
    LimboDancer.MCP.Graph.CosmosGremlin.Tests.csproj
    GremlinSmokeTests.cs
```

---

## src/LimboDancer.MCP.Graph.CosmosGremlin/LimboDancer.MCP.Graph.CosmosGremlin.csproj

```xml
<Project Sdk="Microsoft.NET.Sdk">
  <PropertyGroup>
    <TargetFramework>net9.0</TargetFramework>
    <Nullable>enable</Nullable>
    <ImplicitUsings>enable</ImplicitUsings>
  </PropertyGroup>

  <ItemGroup>
    <PackageReference Include="Gremlin.Net" Version="3.7.2" />
    <PackageReference Include="Microsoft.Extensions.Options.ConfigurationExtensions" Version="9.0.0" />
    <PackageReference Include="Microsoft.Extensions.DependencyInjection.Abstractions" Version="9.0.0" />
  </ItemGroup>
</Project>
```

---

## src/LimboDancer.MCP.Graph.CosmosGremlin/GremlinOptions.cs

```csharp
namespace LimboDancer.MCP.Graph.CosmosGremlin;

public sealed class GremlinOptions
{
    /// <summary>Cosmos DB Gremlin host. Example: your-account.gremlin.cosmos.azure.com</summary>
    public string Host { get; set; } = "";

    /// <summary>Port (Cosmos = 443)</summary>
    public int Port { get; set; } = 443;

    /// <summary>Use TLS for Cosmos (true)</summary>
    public bool EnableSsl { get; set; } = true;

    /// <summary>Cosmos DB database (a.k.a. database/graph account db)</summary>
    public string Database { get; set; } = "";

    /// <summary>Graph (container) name</summary>
    public string Graph { get; set; } = "";

    /// <summary>Primary (or secondary) key</summary>
    public string AuthKey { get; set; } = "";

    /// <summary>Pool size for underlying WebSocket connections</summary>
    public int ConnectionPoolSize { get; set; } = 8;

    /// <summary>Request serializer version; Cosmos Gremlin API supports GraphSON 2.x</summary>
    public GraphSonVersion Serializer { get; set; } = GraphSonVersion.GraphSON2;
}

public enum GraphSonVersion
{
    GraphSON2,
    GraphSON3
}
```

---

## src/LimboDancer.MCP.Graph.CosmosGremlin/GremlinClientFactory.cs

```csharp
using Gremlin.Net.Driver;
using Gremlin.Net.Driver.Remote;
using Gremlin.Net.Structure.IO.GraphSON;
using Microsoft.Extensions.Configuration;
using Microsoft.Extensions.Options;

namespace LimboDancer.MCP.Graph.CosmosGremlin;

public interface IGremlinClientFactory
{
    IGremlinClient Create();
}

public sealed class GremlinClientFactory : IGremlinClientFactory
{
    private readonly GremlinOptions _opts;

    public GremlinClientFactory(IOptions<GremlinOptions> options) => _opts = options.Value;

    /// <summary>
    /// Creates a Gremlin client configured for Cosmos DB Gremlin.
    /// Username must be in the form: /dbs/{db}/colls/{graph}
    /// Password is the Cosmos account key.
    /// </summary>
    public IGremlinClient Create()
    {
        var username = $"/dbs/{_opts.Database}/colls/{_opts.Graph}";
        var server = new GremlinServer(
            hostname: _opts.Host,
            port: _opts.Port,
            enableSsl: _opts.EnableSsl,
            username: username,
            password: _opts.AuthKey);

        // Cosmos Gremlin speaks GraphSON2 today
        IGraphSONMessageSerializer serializer = _opts.Serializer switch
        {
            GraphSonVersion.GraphSON3 => new GraphSON3MessageSerializer(),
            _ => new GraphSON2MessageSerializer()
        };

        // Pooling via GremlinClient constructor overload
        var connectionPoolSettings = new ConnectionPoolSettings
        {
            MaxInProcessPerConnection = 4,
            PoolSize = _opts.ConnectionPoolSize,
            ReconnectionAttempts = 3,
            ReconnectionBaseDelay = TimeSpan.FromSeconds(2)
        };

        return new GremlinClient(
            gremlinServer: server,
            messageSerializer: serializer,
            connectionPoolSettings: connectionPoolSettings);
    }

    // DI helper registration
    public static IServiceCollection AddCosmosGremlin(
        this IServiceCollection services,
        IConfiguration config,
        string sectionName = "CosmosGremlin")
    {
        services.Configure<GremlinOptions>(config.GetSection(sectionName));
        services.AddSingleton<IGremlinClientFactory, GremlinClientFactory>();
        return services;
    }
}
```

---

## src/LimboDancer.MCP.Graph.CosmosGremlin/GraphWriteHelpers.cs

```csharp
using Gremlin.Net.Driver;
using Gremlin.Net.Process.Traversal;
using Gremlin.Net.Structure;

namespace LimboDancer.MCP.Graph.CosmosGremlin;

/// <summary>
/// Minimal helpers for idempotent vertex/edge creation (upsert).
/// Read-sides can be added later.
/// </summary>
public static class GraphWriteHelpers
{
    /// <summary>
    /// Upsert a vertex by id + label with optional properties.
    /// Pattern: g.V(id).fold().coalesce(unfold(), addV(label).property(id,id)).property(k,v)...
    /// </summary>
    public static async Task UpsertVertexAsync(
        IGremlinClient client,
        string id,
        string label,
        IReadOnlyDictionary<string, object>? properties = null,
        CancellationToken ct = default)
    {
        // build gremlin script
        var gremlin = "g.V(id).fold().coalesce(unfold()," +
                      " addV(label).property('id', id))";

        // Add .property(k, p_k) for each provided property
        var bindings = new Dictionary<string, object?>
        {
            ["id"] = id,
            ["label"] = label
        };

        if (properties is { Count: > 0 })
        {
            int i = 0;
            foreach (var (k, v) in properties)
            {
                var keyParam = $"k{i}";
                var valParam = $"v{i}";
                gremlin += $".property({keyParam},{valParam})";
                bindings[keyParam] = k;
                bindings[valParam] = v;
                i++;
            }
        }

        await client.SubmitAsync<dynamic>(gremlin, bindings, ct);
    }

    /// <summary>
    /// Upsert a directed edge (from -> to) with label and optional properties.
    /// Pattern:
    /// g.V(fromId).as('a')
    ///  .V(toId).as('b')
    ///  .select('a').coalesce(
    ///      outE(label).where(inV().hasId(toId)),
    ///      addE(label).to(select('b'))
    ///  ) .property(k,v)...
    /// </summary>
    public static async Task UpsertEdgeAsync(
        IGremlinClient client,
        string @from,
        string to,
        string label,
        IReadOnlyDictionary<string, object>? properties = null,
        CancellationToken ct = default)
    {
        var gremlin =
            "g.V(fromId).as('a').V(toId).as('b')" +
            ".select('a').coalesce(" +
                "outE(label).where(inV().hasId(toId))," +
                "addE(label).to(select('b'))" +
            ")";

        var bindings = new Dictionary<string, object?>
        {
            ["fromId"] = from,
            ["toId"] = to,
            ["label"] = label
        };

        if (properties is { Count: > 0 })
        {
            int i = 0;
            foreach (var (k, v) in properties)
            {
                var keyParam = $"k{i}";
                var valParam = $"v{i}";
                gremlin += $".property({keyParam},{valParam})";
                bindings[keyParam] = k;
                bindings[valParam] = v;
                i++;
            }
        }

        await client.SubmitAsync<dynamic>(gremlin, bindings, ct);
    }
}
```

---

## src/Tests/LimboDancer.MCP.Graph.CosmosGremlin.Tests/LimboDancer.MCP.Graph.CosmosGremlin.Tests.csproj

```xml
<Project Sdk="Microsoft.NET.Sdk">
  <PropertyGroup>
    <TargetFramework>net9.0</TargetFramework>
    <Nullable>enable</Nullable>
    <ImplicitUsings>enable</ImplicitUsings>
  </PropertyGroup>

  <ItemGroup>
    <PackageReference Include="xunit" Version="2.7.0" />
    <PackageReference Include="xunit.runner.visualstudio" Version="2.5.7">
      <PrivateAssets>all</PrivateAssets>
    </PackageReference>
    <PackageReference Include="FluentAssertions" Version="6.12.0" />
    <PackageReference Include="Gremlin.Net" Version="3.7.2" />
    <PackageReference Include="Microsoft.Extensions.Options.ConfigurationExtensions" Version="9.0.0" />
  </ItemGroup>

  <ItemGroup>
    <ProjectReference Include="..\..\LimboDancer.MCP.Graph.CosmosGremlin\LimboDancer.MCP.Graph.CosmosGremlin.csproj" />
  </ItemGroup>
</Project>
```

---

## src/Tests/LimboDancer.MCP.Graph.CosmosGremlin.Tests/GremlinSmokeTests.cs

```csharp
using FluentAssertions;
using Gremlin.Net.Process.Traversal;
using LimboDancer.MCP.Graph.CosmosGremlin;
using Microsoft.Extensions.Configuration;
using Microsoft.Extensions.DependencyInjection;

public class GremlinSmokeTests
{
    private static GremlinOptions LoadFromEnv() => new GremlinOptions
    {
        Host     = Environment.GetEnvironmentVariable("COSMOS_GREMLIN_HOST") ?? "",
        Port     = int.TryParse(Environment.GetEnvironmentVariable("COSMOS_GREMLIN_PORT"), out var p) ? p : 443,
        EnableSsl= true,
        Database = Environment.GetEnvironmentVariable("COSMOS_GREMLIN_DB") ?? "",
        Graph    = Environment.GetEnvironmentVariable("COSMOS_GREMLIN_GRAPH") ?? "",
        AuthKey  = Environment.GetEnvironmentVariable("COSMOS_GREMLIN_KEY") ?? "",
        Serializer = GraphSonVersion.GraphSON2
    };

    [Fact(Skip = "Set COSMOS_GREMLIN_* env vars to run against a live Cosmos Gremlin API.")]
    public async Task Connect_And_Count_Succeeds()
    {
        var opts = LoadFromEnv();
        if (string.IsNullOrWhiteSpace(opts.Host)) return;

        var services = new ServiceCollection();
        services.AddOptions<GremlinOptions>().Configure(o =>
        {
            o.Host = opts.Host;
            o.Port = opts.Port;
            o.EnableSsl = opts.EnableSsl;
            o.Database = opts.Database;
            o.Graph = opts.Graph;
            o.AuthKey = opts.AuthKey;
            o.Serializer = opts.Serializer;
        });
        services.AddSingleton<IGremlinClientFactory, GremlinClientFactory>();

        var sp = services.BuildServiceProvider();
        var factory = sp.GetRequiredService<IGremlinClientFactory>();
        await using var client = factory.Create();

        // g.V().limit(1).count()
        var result = await client.SubmitAsync<long>("g.V().limit(1).count()");
        result.Should().NotBeNull();
        result.Count.Should().Be(1);
        result[0].Should().BeGreaterThanOrEqualTo(0);
    }
}
```

---

## Example configuration (appsettings.Development.json)

```json
{
  "CosmosGremlin": {
    "Host": "your-account.gremlin.cosmos.azure.com",
    "Port": 443,
    "EnableSsl": true,
    "Database": "limbodancer",
    "Graph": "history_memory_graph",
    "AuthKey": "YOUR-PRIMARY-KEY",
    "ConnectionPoolSize": 8,
    "Serializer": "GraphSON2"
  }
}
```

### DI (where you bootstrap your app)

```csharp
// builder.Services.AddCosmosGremlin(builder.Configuration); // uses "CosmosGremlin" section
```

---

## Smoke test (CLI quick run)

```bash
# Export your live values:
export COSMOS_GREMLIN_HOST="your-account.gremlin.cosmos.azure.com"
export COSMOS_GREMLIN_DB="limbodancer"
export COSMOS_GREMLIN_GRAPH="history_memory_graph"
export COSMOS_GREMLIN_KEY="YOUR_PRIMARY_KEY"
# optional
export COSMOS_GREMLIN_PORT=443

# Enable the test (remove [Skip]) or copy the 1-liner into a console app.
dotnet test src/Tests/LimboDancer.MCP.Graph.CosmosGremlin.Tests
```

---

### Notes

* Uses **GraphSON2** serializer by default to match Cosmos Gremlin API.
* `UpsertVertexAsync`/`UpsertEdgeAsync` are **idempotent** patterns built with `coalesce(...)`.
* Factory exposes a straight **`IGremlinClient`**; we keep helpers static and read‑only for now as requested.
* Pooling, reconnection, SSL, and username format `/dbs/{db}/colls/{graph}` are pre‑wired.

If you want this wired into your **Operator Console** (read views for vertices/edges) or a **CLI** verb (`kg ping`, `kg put-vertex`, `kg put-edge`) next, I can package that as PR‑4.
