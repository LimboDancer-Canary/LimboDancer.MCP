**PR-4** for **Developer CLI** with `System.CommandLine`, reusing your Storage, Vector, and Graph libs. It defaults to **Chat-only** migrations (Audit optional later), uses **random embeddings** for smoke tests (so no AOAI needed), and includes all commands you listed.

---

# PR-4: `src/LimboDancer.MCP.Cli` (console)

### `src/LimboDancer.MCP.Cli/LimboDancer.MCP.Cli.csproj`

```xml
<Project Sdk="Microsoft.NET.Sdk">
  <PropertyGroup>
    <OutputType>Exe</OutputType>
    <TargetFramework>net9.0</TargetFramework>
    <Nullable>enable</Nullable>
    <ImplicitUsings>enable</ImplicitUsings>
  </PropertyGroup>

  <ItemGroup>
    <PackageReference Include="System.CommandLine" Version="2.0.0-beta4.22272.1" />
    <PackageReference Include="Azure.Search.Documents" Version="11.5.1" />
    <PackageReference Include="Gremlin.Net" Version="3.6.5" />
    <PackageReference Include="Microsoft.EntityFrameworkCore.Design" Version="9.0.0">
      <PrivateAssets>all</PrivateAssets>
    </PackageReference>
  </ItemGroup>

  <ItemGroup>
    <ProjectReference Include="..\LimboDancer.MCP.Core\LimboDancer.MCP.Core.csproj" />
    <ProjectReference Include="..\LimboDancer.MCP.Storage\LimboDancer.MCP.Storage.csproj" />
    <ProjectReference Include="..\LimboDancer.MCP.Vector.AzureSearch\LimboDancer.MCP.Vector.AzureSearch.csproj" />
    <ProjectReference Include="..\LimboDancer.MCP.Graph.CosmosGremlin\LimboDancer.MCP.Graph.CosmosGremlin.csproj" />
  </ItemGroup>
</Project>
```

---

### `src/LimboDancer.MCP.Cli/Program.cs`

```csharp
using System.CommandLine;
using Microsoft.Extensions.Configuration;
using Microsoft.Extensions.DependencyInjection;
using Microsoft.Extensions.Hosting;
using LimboDancer.MCP.Cli.Commands;

var root = new RootCommand("LimboDancer.MCP CLI");

root.AddCommand(ServeCommand.Build());
root.AddCommand(DbMigrateCommand.Build());
root.AddCommand(VectorInitCommand.Build());
root.AddCommand(KgPingCommand.Build());
root.AddCommand(MemAddCommand.Build());
root.AddCommand(MemSearchCommand.Build());

return await root.InvokeAsync(args);

// Shared host bootstrap for all commands
internal static class Bootstrap
{
    public static IHost BuildHost(string[]? args = null)
    {
        var b = Host.CreateApplicationBuilder(args ?? Array.Empty<string>());

        b.Configuration
          .AddJsonFile("appsettings.json", optional:true)
          .AddJsonFile("appsettings.Development.json", optional:true)
          .AddEnvironmentVariables();

        ServicesBootstrap.Configure(b);
        return b.Build();
    }
}
```

---

### `src/LimboDancer.MCP.Cli/Commands/ServicesBootstrap.cs`

```csharp
using Azure;
using Azure.Search.Documents;
using Azure.Search.Documents.Indexes;
using Gremlin.Net.Driver;
using LimboDancer.MCP.Graph.CosmosGremlin;
using LimboDancer.MCP.Storage;
using LimboDancer.MCP.Vector.AzureSearch;
using Microsoft.EntityFrameworkCore;
using Microsoft.Extensions.Configuration;
using Microsoft.Extensions.DependencyInjection;

namespace LimboDancer.MCP.Cli.Commands;

internal static class ServicesBootstrap
{
    public static void Configure(HostApplicationBuilder b)
    {
        var cfg = b.Configuration;

        // EF Core (Chat) — Audit can be added later
        b.Services.AddDbContext<ChatDbContext>(opt =>
        {
            var cs = cfg["Persistence:ConnectionString"] ?? throw new InvalidOperationException("Missing Persistence:ConnectionString");
            opt.UseNpgsql(cs);
        });

        b.Services.AddScoped<IChatHistoryStore, ChatHistoryStore>();

        // Azure AI Search clients
        b.Services.AddSingleton<SearchIndexClient>(_ =>
        {
            var endpoint = new Uri(cfg["Search:Endpoint"]!);
            var key = new AzureKeyCredential(cfg["Search:ApiKey"]!);
            return new SearchIndexClient(endpoint, key);
        });

        b.Services.AddSingleton<SearchClient>(_ =>
        {
            var endpoint = new Uri(cfg["Search:Endpoint"]!);
            var key = new AzureKeyCredential(cfg["Search:ApiKey"]!);
            var index = cfg["Search:Index"] ?? "ldm-memory";
            return new SearchClient(endpoint, index, key);
        });

        // Vector store (embed delegate is supplied by MemAddCommand at call time)
        b.Services.AddSingleton<VectorStore>();

        // Gremlin client
        b.Services.AddSingleton<IGremlinClient>(_ =>
        {
            var opts = new GremlinOptions
            {
                Host       = cfg["Gremlin:Host"]!,
                Port       = int.TryParse(cfg["Gremlin:Port"], out var p) ? p : 443,
                Database   = cfg["Gremlin:Database"]!,
                Graph      = cfg["Gremlin:Graph"]!,
                PrimaryKey = cfg["Gremlin:Key"]!
            };
            return GremlinClientFactory.Create(opts);
        });
    }
}
```

---

### `src/LimboDancer.MCP.Cli/Commands/ServeCommand.cs`

```csharp
using System.CommandLine;

namespace LimboDancer.MCP.Cli.Commands;

internal static class ServeCommand
{
    public static Command Build()
    {
        var cmd = new Command("serve", "Run the MCP server");
        var stdio = new Option<bool>("--stdio", description: "Run in stdio mode.");
        cmd.AddOption(stdio);

        cmd.SetHandler((bool useStdio) =>
        {
            using var host = Bootstrap.BuildHost();

            if (useStdio)
            {
                Console.WriteLine("serve --stdio: stub runner — wire MCP here");
                return;
            }

            Console.WriteLine("No HTTP runner exposed via CLI yet.");
        }, stdio);

        return cmd;
    }
}
```

---

### `src/LimboDancer.MCP.Cli/Commands/DbMigrateCommand.cs`

```csharp
using System.CommandLine;
using LimboDancer.MCP.Storage;
using Microsoft.EntityFrameworkCore;
using Microsoft.Extensions.DependencyInjection;

namespace LimboDancer.MCP.Cli.Commands;

internal static class DbMigrateCommand
{
    public static Command Build()
    {
        var cmd = new Command("db", "Database utilities");
        var migrate = new Command("migrate", "Apply EF Core migrations (Chat; Audit optional later)");

        migrate.SetHandler(async () =>
        {
            using var host = Bootstrap.BuildHost();
            await using var scope = host.Services.CreateAsyncScope();

            var chat = scope.ServiceProvider.GetRequiredService<ChatDbContext>();
            Console.WriteLine("Applying ChatDbContext migrations…");
            await chat.Database.MigrateAsync();
            Console.WriteLine("Done.");

            // If/when you add AuditDbContext, repeat here (guarded).
        });

        cmd.AddCommand(migrate);
        return cmd;
    }
}
```

---

### `src/LimboDancer.MCP.Cli/Commands/VectorInitCommand.cs`

```csharp
using System.CommandLine;
using Azure.Search.Documents.Indexes;
using LimboDancer.MCP.Vector.AzureSearch;
using Microsoft.Extensions.DependencyInjection;

namespace LimboDancer.MCP.Cli.Commands;

internal static class VectorInitCommand
{
    public static Command Build()
    {
        var cmd = new Command("vector", "Vector index ops");
        var init = new Command("init", "Ensure Azure AI Search index exists");

        var dim     = new Option<int>("--dim", () => 1536, "Embedding dimensions");
        var profile = new Option<string>("--profile", () => SearchIndexBuilder.DefaultVectorProfile, "Vector profile name");
        var index   = new Option<string?>("--index", "Override index name");

        init.AddOption(dim); init.AddOption(profile); init.AddOption(index);

        init.SetHandler(async (int d, string prof, string? idxName) =>
        {
            using var host = Bootstrap.BuildHost();
            var ic = host.Services.GetRequiredService<SearchIndexClient>();

            var cfg = host.Services.GetRequiredService<IConfiguration>();
            var indexName = idxName ?? cfg["Search:Index"] ?? SearchIndexBuilder.DefaultIndexName;

            await SearchIndexBuilder.EnsureIndexAsync(ic, indexName, embeddingDimensions: d, vectorProfileName: prof);
            Console.WriteLine($"Index '{indexName}' ensured (dim={d}, profile={prof}).");
        }, dim, profile, index);

        cmd.AddCommand(init);
        return cmd;
    }
}
```

---

### `src/LimboDancer.MCP.Cli/Commands/KgPingCommand.cs`

```csharp
using System.CommandLine;
using Gremlin.Net.Driver;
using Microsoft.Extensions.DependencyInjection;

namespace LimboDancer.MCP.Cli.Commands;

internal static class KgPingCommand
{
    public static Command Build()
    {
        var cmd = new Command("kg", "Knowledge graph utilities");
        var ping = new Command("ping", "Gremlin count");

        ping.SetHandler(async () =>
        {
            using var host = Bootstrap.BuildHost();
            var g = host.Services.GetRequiredService<IGremlinClient>();

            var rs = await g.SubmitAsync<long>("g.V().limit(1).count()");
            var count = rs.Count > 0 ? rs[0] : 0;
            Console.WriteLine($"Gremlin OK. Sample vertex count: {count}");
        });

        cmd.AddCommand(ping);
        return cmd;
    }
}
```

---

### `src/LimboDancer.MCP.Cli/Commands/MemAddCommand.cs`

```csharp
using System.CommandLine;
using System.Security.Cryptography;
using System.Text;
using Azure.Search.Documents;
using LimboDancer.MCP.Vector.AzureSearch;
using Microsoft.Extensions.Configuration;
using Microsoft.Extensions.DependencyInjection;
using static LimboDancer.MCP.Vector.AzureSearch.VectorStore;

namespace LimboDancer.MCP.Cli.Commands;

internal static class MemAddCommand
{
    public static Command Build()
    {
        var cmd = new Command("mem", "Vector memory ops");
        var add = new Command("add", "Ingest text/file -> chunk -> embed -> upsert");

        var file     = new Option<string?>("--file", "Path to a text/markdown file");
        var text     = new Option<string?>("--text", "Raw text to ingest");
        var title    = new Option<string?>("--title", () => "CLI Ingest", "Title");
        var source   = new Option<string?>("--source", () => "cli", "Source");
        var klass    = new Option<string?>("--class",  () => "ldm:MemoryItem", "Ontology class");
        var tagsCsv  = new Option<string?>("--tags",   () => "kind:vector,source:cli", "CSV tags");
        var maxChars = new Option<int>("--max-chars",  () => 1200, "Chunk size (characters)");
        var dim      = new Option<int>("--dim",        () => 1536, "Embedding dimensions (for random embedding)");

        add.AddOption(file); add.AddOption(text); add.AddOption(title); add.AddOption(source);
        add.AddOption(klass); add.AddOption(tagsCsv); add.AddOption(maxChars); add.AddOption(dim);

        add.SetHandler(async (string? file, string? text, string? title, string? source, string? klass, string? tagsCsv, int maxChars, int dim) =>
        {
            using var host = Bootstrap.BuildHost();
            var cfg = host.Services.GetRequiredService<IConfiguration>();
            var client = host.Services.GetRequiredService<SearchClient>();

            // Deterministic random embedder (no external services needed)
            Task<float[]> EmbedAsync(string s)
            {
                var vec = new float[dim];
                var seed = SeedFrom(s);
                var rng = new Random(seed);
                for (int i = 0; i < dim; i++) vec[i] = (float)(rng.NextDouble() - 0.5); // [-0.5, 0.5)
                return Task.FromResult(vec);
            }

            var store = new VectorStore(client, EmbedAsync);

            var raw = string.IsNullOrWhiteSpace(file)
                ? text
                : await File.ReadAllTextAsync(file!);

            if (string.IsNullOrWhiteSpace(raw))
            {
                Console.Error.WriteLine("Provide --file or --text");
                return;
            }

            var chunks = ChunkBySentences(raw!, maxChars);
            Console.WriteLine($"Chunks: {chunks.Count}");

            var now = DateTimeOffset.UtcNow;
            var docs = new List<MemoryDoc>();
            for (int i = 0; i < chunks.Count; i++)
            {
                var id = Guid.NewGuid().ToString("N");
                docs.Add(new MemoryDoc
                {
                    Id = id,
                    Title = title,
                    Content = chunks[i],
                    Source = source,
                    Chunk = i,
                    CreatedAt = now,
                    OntologyClass = klass,
                    Uri = $"ldm:MemoryItem#{id}",
                    Tags = (tagsCsv ?? "").Split(',', StringSplitOptions.RemoveEmptyEntries | StringSplitOptions.TrimEntries)
                });
            }

            await store.UpsertAsync(docs, embedIfMissing: true);
            Console.WriteLine("Upsert complete.");
        }, file, text, title, source, klass, tagsCsv, maxChars, dim);

        cmd.AddCommand(add);
        return cmd;
    }

    private static int SeedFrom(string s)
    {
        using var md5 = MD5.Create();
        var hash = md5.ComputeHash(Encoding.UTF8.GetBytes(s));
        return Math.Abs(BitConverter.ToInt32(hash, 0));
    }

    private static List<string> ChunkBySentences(string text, int maxChars)
    {
        var parts = SplitSentences(text);
        var chunks = new List<string>();
        var sb = new StringBuilder(maxChars + 64);

        foreach (var s in parts)
        {
            if (sb.Length + s.Length + 1 > maxChars && sb.Length > 0)
            {
                chunks.Add(sb.ToString().Trim());
                sb.Clear();
            }
            sb.AppendLine(s);
        }
        if (sb.Length > 0) chunks.Add(sb.ToString().Trim());
        return chunks;
    }

    private static IEnumerable<string> SplitSentences(string text)
    {
        foreach (var para in text.Split(new[] { "\r\n\r\n", "\n\n" }, StringSplitOptions.RemoveEmptyEntries))
        {
            var p = para.Replace("\r\n", " ").Replace('\n', ' ').Trim();
            if (p.Length == 0) continue;

            var acc = new StringBuilder();
            foreach (var token in p.Split(' ', StringSplitOptions.RemoveEmptyEntries))
            {
                acc.Append(token).Append(' ');
                if (token.EndsWith('.') || token.EndsWith('!') || token.EndsWith('?'))
                {
                    yield return acc.ToString().Trim();
                    acc.Clear();
                }
            }
            if (acc.Length > 0) yield return acc.ToString().Trim();
        }
    }
}
```

---

### `src/LimboDancer.MCP.Cli/Commands/MemSearchCommand.cs`

```csharp
using System.CommandLine;
using LimboDancer.MCP.Vector.AzureSearch;
using Microsoft.Extensions.DependencyInjection;

namespace LimboDancer.MCP.Cli.Commands;

internal static class MemSearchCommand
{
    public static Command Build()
    {
        var cmd = new Command("mem", "Vector memory ops");
        var search = new Command("search", "Hybrid search (BM25 + vector)");

        var query = new Option<string?>("--query", "BM25/Semantic query text");
        var k     = new Option<int>("--k", () => 8, "Top K");
        var oc    = new Option<string?>("--class", "Filter: ontologyClass");
        var uri   = new Option<string?>("--uri", "Filter: URI equals");
        var tags  = new Option<string[]>("--tag", parseArgument: r => r.Tokens.Select(t => t.Value).ToArray(), description: "Filter: any tag");

        search.AddOption(query); search.AddOption(k); search.AddOption(oc); search.AddOption(uri); search.AddOption(tags);

        search.SetHandler(async (string? q, int topK, string? klass, string? uriEq, string[] tagArr) =>
        {
            using var host = Bootstrap.BuildHost();
            var store = host.Services.GetRequiredService<VectorStore>();

            var filters = new VectorStore.SearchFilters
            {
                OntologyClass = klass,
                UriEquals = uriEq,
                TagsAny = tagArr?.Length > 0 ? tagArr : null
            };

            var res = await store.SearchHybridAsync(q, vector: null, k: topK, filters: filters);
            foreach (var r in res)
            {
                Console.WriteLine($"[{r.Score:F3}] {r.Title}  {r.Source}#{r.Chunk}  class={r.OntologyClass}  tags=[{string.Join(",", r.Tags ?? Array.Empty<string>())}]");
                var prev = r.Content?.Length > 200 ? r.Content[..200] + "…" : r.Content;
                Console.WriteLine(prev + "\n");
            }
        }, query, k, oc, uri, tags);

        cmd.AddCommand(search);
        return cmd;
    }
}
```

---

### `src/LimboDancer.MCP.Cli/appsettings.Development.json` (sample)

```json
{
  "Persistence": {
    "ConnectionString": "Host=localhost;Port=5432;Database=limbodancer_dev;Username=postgres;Password=postgres"
  },
  "Search": {
    "Endpoint": "https://<search>.search.windows.net",
    "ApiKey": "<key>",
    "Index": "ldm-memory"
  },
  "Gremlin": {
    "Host": "localhost",
    "Port": "8901",
    "Database": "ldm",
    "Graph": "kg",
    "Key": "<emulator-or-account-key>"
  }
}
```

---

## Smoke test (matches your checklist)

```bash
# From repo root
dotnet build

dotnet run --project src/LimboDancer.MCP.Cli -- db migrate

dotnet run --project src/LimboDancer.MCP.Cli -- vector init --dim 1536

dotnet run --project src/LimboDancer.MCP.Cli -- kg ping

dotnet run --project src/LimboDancer.MCP.Cli -- mem add --text "hello world" --tags test

dotnet run --project src/LimboDancer.MCP.Cli -- mem search --query hello
```

### Notes

* **Audit DB**: when you add it, extend `DbMigrateCommand` and `ServicesBootstrap` (guarded) to migrate both.
* **Embeddings**: the CLI uses **deterministic random vectors** for dev. Swap the embed delegate in `MemAddCommand` to call your Azure OpenAI deployment when you’re ready.
* **Tests folder move**: the CLI is independent of the tests layout; no changes needed.

If you want, I can also add a tiny `docs/DEVSETUP.md` to the repo root and a `dotnet tool` manifest so you can install the CLI globally (`dotnet tool install --local`).
