# 9. Full Operator Console (interactive/debugging)

This console is **multi-tenant aware**. Every page and action is scoped to a selected `{tenant,package,channel}`. Cross‑tenant browsing and writes are disabled by design. The active scope is visible in the header and included in all API calls.

Here is a **PR-ready backlog** to complete **Milestone 9: Full Operator Console (interactive & debugging)**. I organized it into phased tickets with clear deliverables, file paths, acceptance criteria, and test notes so you can land work in small, shippable PRs.

---

# Milestone 9 — Operator Console (Interactive)

## Phase A — Wiring, UX polish, and auth

### A1. Shell + Nav + Auth Guard

**Goal:** Add left-nav, page routes, and a minimal auth guard so the console isn’t accidentally public.

* **Files**

  * `src/LimboDancer.MCP.BlazorConsole/Shared/MainLayout.razor`
  * `src/LimboDancer.MCP.BlazorConsole/App.razor`
  * `src/LimboDancer.MCP.BlazorConsole/Pages/{Sessions.razor,Memory.razor,Graph.razor,Ingestion.razor}`
  * `src/LimboDancer.MCP.BlazorConsole/Services/AuthState.cs` (new)
* **Work**

  * Add a left nav (Sessions / Memory / Graph / Ingestion / Live).
  * Add `CascadingAuthenticationState` (stub ok) and simple role check `Operator`.
  * Gate pages with `[Authorize(Roles="Operator")]` (or a central check if not using ASP.NET Identity now).
* **Acceptance**

  * Navigating directly to `/sessions` without “Operator” shows an access message.
  * Left nav highlights current route.

### A2. Design tokens + table helpers

**Goal:** Consistent typography/spacings and reusable table helpers.

* **Files**

  * `src/LimboDancer.MCP.BlazorConsole/wwwroot/css/site.css` (tokens)
  * `src/LimboDancer.MCP.BlazorConsole/Components/DataTable.razor` (new, minimal)
* **Acceptance**

  * All existing grids use the shared table component; zebra rows, fixed header, monospace for IDs.

---

## Phase B — Sessions: tagging, resend, redact

### B1. Session Tags (read/write)

**Goal:** Add **tags** to sessions to help triage.

* **Files**

  * `.../Pages/Sessions.razor` (extend right pane)
  * `.../Services/SessionsService.cs` (add `SetTagsAsync(sessionId, tags[])`)
  * `src/LimboDancer.MCP.Storage/ChatDbContext.cs` (+ small repo if you prefer)
* **Work**

  * Show editable chips (comma input → normalized string\[]).
  * Persist into `Sessions.TagsJson` (already `jsonb`).
* **Acceptance**

  * Add/remove tags, reload page → tags persist.
  * Empty tags removes `TagsJson` field.

### B2. Resend message to tool / assistant (dry-run)

**Goal:** Re-invoke a message (assistant/tool) in **dry-run** to inspect effects without commit.

* **Files**

  * `.../Pages/Sessions.razor` (message row → “Re-invoke” button)
  * `src/LimboDancer.MCP.BlazorConsole/Services/ToolsService.cs` (new; calls MCP server)
* **Work**

  * If message has tool metadata → POST to MCP `/tools/call` with `dryRun=true`.
  * Render returned payload + proposed effects in a modal (JSON pretty).
* **Acceptance**

  * Clicking “Re-invoke” shows result JSON and any `proposed_effects`.
  * No state changes occur on server side (dry-run confirmed).

### B3. Redact message content (soft-delete/redact)

**Goal:** Mask sensitive content but retain timeline.

* **Files**

  * `.../Pages/Sessions.razor` (Context menu → “Redact”)
  * `src/LimboDancer.MCP.Storage/Entities.cs` (add `IsRedacted` bool + optional `RedactionReason`)
  * Migration: `IsRedacted` default false, `RedactionReason` text.
* **Acceptance**

  * Redacted rows show “▮▮▮ redacted” and tooltip with reason.
  * Export APIs omit or mask redacted content.

---

## Phase C — Memory: add, delete, and pin

### C1. Add to Memory (manual ingest)

**Goal:** Operator pastes text → chunk, embed, upsert into Azure AI Search (reusing VectorStore).

* **Files**

  * `.../Pages/Ingestion.razor` (new page already listed)
  * `.../Services/MemoryService.cs` (add `AddAsync(text, title, tags, class, chunkSize)` calling VectorStore)
* **Work**

  * Minimal form: Title, Text, Tags (CSV), OntologyClass (input), Chunk size.
  * Progress status + result list (IDs).
* **Acceptance**

  * New items appear in `/memory` search immediately.

### C2. Delete / Tombstone memory item

**Goal:** Allow delete (or tombstone) by Id.

* **Files**

  * `.../Pages/Memory.razor` (row action)
  * `.../Services/MemoryService.cs` (add `DeleteAsync(id)` or `TombstoneAsync(id)`)
* **Acceptance**

  * Item disappears from search; if tombstoned, `/memory?include=deleted` shows it.

### C3. Pin memory item to session

**Goal:** Link a memory item to a session (context pin).

* **Files**

  * `.../Pages/Memory.razor` (action “Pin to session” → select session)
  * `.../Services/SessionsService.cs` (new `AddReferenceAsync(sessionId, memoryId)` → creates a Message with `references`)
  * (Optional KG) `GraphService` `AddEdge Session -hasMessage-> Message -references-> MemoryItem`
* **Acceptance**

  * Pinned memory shows under the session message list with a “Referenced” badge.

---

## Phase D — Graph: inspect & write

### D1. Vertex details & adjacent edges

**Goal:** Click a vertex → show properties + out/in edges with small paging.

* **Files**

  * `.../Pages/Graph.razor` (details pane)
  * `.../Services/GraphService.cs` (already has `GetOutEdgesAsync`; add `GetInEdgesAsync`, `GetVertexByIdAsync`)
* **Acceptance**

  * Selecting vertex loads 1) properties, 2) top N in/out edges.

### D2. Create edge wizard (guarded)

**Goal:** Controlled write: add `references` or `hasMessage` edges only.

* **Files**

  * `.../Pages/Graph.razor` (modal)
  * `.../Services/GraphService.cs` (add `CreateEdgeAsync(outId,label,inId)`)
* **Acceptance**

  * Only allow whitelisted labels; success toast + appears in list.
  * Invalid IDs show a clear error.

---

## Phase E — Live ops: SSE tail + health

### E1. Live Message Tail (SSE)

**Goal:** `/live` page that streams recent messages/sessions via SSE.

* **Files**

  * `src/LimboDancer.MCP.BlazorConsole/Pages/Live.razor` (new)
  * `src/LimboDancer.MCP.BlazorConsole/Services/SseClient.cs` (new; EventSource wrapper)
  * Server: confirm `_6. HTTP transport hardening + SSE events` endpoint name and payload shape
* **Work**

  * Connect to SSE endpoint; render lines with compact layout; pause/resume button.
* **Acceptance**

  * New messages appear within 1–2s; pause stops UI updates without closing connection.

### E2. Health panel

**Goal:** Inline checks for Postgres, Search, Gremlin.

* **Files**

  * `.../Pages/Live.razor` (right panel)
  * `.../Services/HealthService.cs` (new; calls `db.CanConnectAsync()`, `SearchClient.GetIndexNames`, `g.V().limit(1)`)
* **Acceptance**

  * Green/amber/red indicators with last-checked timestamp and exception snippets.

---

## Phase F — Tooling actions: invoke & apply effects

### F1. Invoke MCP tool with guardrails

**Goal:** Console form to invoke any **exposed tool** with JSON args.

* **Files**

  * `.../Pages/Tools.razor` (new)
  * `.../Services/ToolsService.cs` (already added in B2; extend with `ListToolsAsync()`)
* **Work**

  * Dropdown of tools from `tools/list`; JSON editor for arguments; checkbox **Dry-run**.
  * Pretty show **result** and **proposed\_effects**.
* **Acceptance**

  * Dry-run does not mutate; uncheck applies (server must support non-dry-run).

### F2. Apply proposed effect (two-step)

**Goal:** When a prior call returned `proposed_effects`, enable explicit “Apply” to commit.

* **Files**

  * `.../Pages/Tools.razor`
  * `.../Services/ToolsService.cs` (add `ApplyEffectAsync(effect)` if server exposes endpoint; else a specialized tool)
* **Acceptance**

  * After apply, a confirmation appears; related session/graph views reflect the change after refresh.

---

## Phase G — DX, safety, and tests

### G1. Error envelope + toasts

* Normalize service exceptions → `(title, details, correlationId?)` and toast.
* Add client-side retry for transient 429/503.

### G2. Minimal unit tests (bvt)

* **Projects**

  * `tests/LimboDancer.MCP.BlazorConsole.Tests`
* **Tests**

  * SessionsService: tags roundtrip.
  * MemoryService: add → search → delete.
  * GraphService: in/out edge listing shape (mocks).
  * ToolsService: list→call (dry-run) happy path (mock HTTP).

### G3. RBAC switch + audit hook

* Add a config flag to disable writes globally (read-only mode).
* Emit a simple audit row on any write (user, action, when, payload hash).

---

## Implementation Notes (short)

* **HTTP/MCP endpoints**: You already have server pieces outlined; for now the console can call:

  * `GET /mcp/tools/list`, `POST /mcp/tools/call` (dryRun bool)
  * `GET /sse/messages` (from your SSE doc)
  * Vector ops: reuse `SearchClient` directly (already done).
  * Graph writes: wrap `IGremlinClient.SubmitAsync` with **label allow-list**.
* **Redaction**: prefer soft-delete to preserve message ordering; mask on read and include `RedactionReason`.
* **JSON views**: add a small `<JsonView value="object" />` component with collapsible sections.
* **Safety**: add an **“Are you sure?”** dialog for any write; require typing the target ID to confirm.

---

## What to tackle first (recommended PR sequence)

1. **A1 + A2** (shell + tokens)
2. **B1** (session tags)
3. **B2** (dry-run re-invoke)
4. **C1** (manual memory ingest)
5. **D1** (graph details)
6. **E1** (SSE live tail)
7. **F1** (generic tool invoke)
8. **B3/C2/D2/F2** (writes behind confirm dialogs)
9. **G-series** (tests, audit, RBAC)

If you want, I can generate the **first PR (A1 + A2)** with the layout, nav, tokens, and a tiny `AuthState` guard so you can merge and iterate.
