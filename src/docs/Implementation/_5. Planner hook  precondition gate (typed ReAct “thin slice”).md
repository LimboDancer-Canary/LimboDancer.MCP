# 5. **Planner hook + precondition gate (typed ReAct “thin slice”)**

   * Files: `src/LimboDancer.MCP.Core/Planning/{PlanStep.cs, Planner.cs}` with an interface the server calls before invoking a tool; use KG precondition check helper.
   * Start with a simple “one-step” plan that refuses when preconditions fail; log an audit record.
   * Why: This is Milestone 5’s minimum and ties ontology to real execution.&#x20;
   
   ---
   
   Awesome — here’s the **typed ReAct “thin slice” planner** with a **precondition gate**.

It gives you:

* `PlanStep` / `PlanResult` types
* `IPlanner` with a concrete `SimplePlanner`
* A tiny `IAuditSink` + `LoggingAuditSink`
* Uses your **`PreconditionsEvaluator`** (Cosmos Gremlin) to enforce ontology preconditions before a tool is invoked
* **Subject-id detection** from `ToolSchemaBinding` (matches precondition’s `Subject` to an input field’s `OntologyId`)

> You just call the planner from your MCP server right before `CallToolHandler` executes the tool.

---

### **Planner context**
Each planning cycle carries `{ tenant, package, channel }`. The planner:

1. Resolves the tenant’s **OntologyStore**.
2. Inserts the scope into every tool call.
3. Evaluates preconditions and effects only within the same scope.
4. Refuses cross‑tenant references with a typed error (`scope_mismatch`).

---

## `src/LimboDancer.MCP.Core/Planning/PlanStep.cs`

```csharp
using System.Text.Json;

namespace LimboDancer.MCP.Core.Planning;

/// <summary>High-level decision the planner makes for this step.</summary>
public enum PlanDecision
{
    Proceed = 0,
    RefusePreconditionFailed = 1,
    RefuseUnsupported = 2
}

/// <summary>
/// A minimal, typed ReAct-like step: Thought → (maybe) Action → Observation.
/// We only need enough for a one-step gate now.
/// </summary>
public sealed class PlanStep
{
    public string Thought { get; init; } = "";                         // why we're doing this
    public string ToolName { get; init; } = "";                        // the action (MCP tool)
    public IReadOnlyDictionary<string, object?> Arguments { get; init; } = new Dictionary<string, object?>();
    public PlanDecision Decision { get; init; } = PlanDecision.Proceed;
    public string? RefusalReason { get; init; }                        // populated when decision != Proceed

    /// <summary>Optional: any effects we intend to apply (from ontology binding).</summary>
    public IReadOnlyList<object>? ProposedEffects { get; init; }

    /// <summary>Optional: what we observed when dry-running/validating (unused in thin slice).</summary>
    public string? Observation { get; init; }

    /// <summary>Sanitized args for audit (no secrets).</summary>
    public JsonElement? SanitizedArgsJson { get; init; }
}
```

---

## `src/LimboDancer.MCP.Core/Planning/Planner.cs`

```csharp
using System.Text.Json;
using System.Text.Json.Nodes;
using LimboDancer.MCP.Graph.CosmosGremlin;
using LimboDancer.MCP.Ontology;
using Microsoft.Extensions.Logging;

namespace LimboDancer.MCP.Core.Planning;

public interface IPlanner
{
    /// <summary>
    /// Build a one-step plan for invoking a tool, enforcing ontology preconditions via the KG.
    /// </summary>
    Task<PlanStep> PlanAndAuthorizeAsync(
        ToolSchemaBinding binding,
        IReadOnlyDictionary<string, object?> args,
        CancellationToken ct = default);
}

/// <summary>Simple audit record that you can later persist to DB if desired.</summary>
public sealed class AuditRecord
{
    public Guid Id { get; init; } = Guid.NewGuid();
    public DateTime TimestampUtc { get; init; } = DateTime.UtcNow;

    public string ToolName { get; init; } = "";
    public string Decision { get; init; } = "";
    public string? Reason { get; init; }

    public string? SubjectLabel { get; init; }
    public string? SubjectId { get; init; }

    public JsonElement? Arguments { get; init; }
    public IReadOnlyList<string>? Preconditions { get; init; }
    public IReadOnlyList<string>? Effects { get; init; }
}

public interface IAuditSink
{
    Task WriteAsync(AuditRecord record, CancellationToken ct = default);
}

/// <summary>Default audit sink that logs to the app logger. Swap for DB-backed later.</summary>
public sealed class LoggingAuditSink(ILogger<LoggingAuditSink> logger) : IAuditSink
{
    public Task WriteAsync(AuditRecord record, CancellationToken ct = default)
    {
        logger.LogInformation("[AUDIT] Tool={Tool} Decision={Decision} Reason={Reason} Subject={SubjectLabel}/{SubjectId}",
            record.ToolName, record.Decision, record.Reason, record.SubjectLabel, record.SubjectId);
        return Task.CompletedTask;
    }
}

/// <summary>
/// Single-step planner:
/// - Maps subject instance (id) from binding.Input where field.@id == precondition.Subject
/// - Evaluates all preconditions with PreconditionsEvaluator
/// - If any fail, returns Refuse + writes an audit record
/// - Otherwise returns Proceed, including proposed effects for transparency
/// </summary>
public sealed class SimplePlanner : IPlanner
{
    private readonly PreconditionsEvaluator _preconditions;
    private readonly IAuditSink _audit;
    private readonly ILogger<SimplePlanner> _log;

    public SimplePlanner(PreconditionsEvaluator preconditions, IAuditSink audit, ILogger<SimplePlanner> log)
    {
        _preconditions = preconditions;
        _audit = audit;
        _log = log;
    }

    public async Task<PlanStep> PlanAndAuthorizeAsync(
        ToolSchemaBinding binding,
        IReadOnlyDictionary<string, object?> args,
        CancellationToken ct = default)
    {
        var toolName = binding.Name ?? "<unnamed>";
        var sanitizedArgs = SanitizeArgs(args);

        // 1) Identify the subject label and id we should validate against
        var subjectLabel = FirstNonEmpty(binding.Preconditions?.Select(p => p.Subject)) ?? GuessSubjectFromEffects(binding) ?? "Thing";
        var subjectId = TryFindSubjectId(binding, subjectLabel, args);

        if (binding.Preconditions?.Count > 0)
        {
            // If we have preconditions but no subject id, we must refuse
            if (string.IsNullOrWhiteSpace(subjectId))
            {
                var reason = $"Missing subject id for '{subjectLabel}' to evaluate preconditions.";
                await AuditAsync(toolName, "RefusePreconditionFailed", reason, subjectLabel, subjectId, sanitizedArgs, binding);
                return Refusal(toolName, sanitizedArgs, binding, subjectLabel, subjectId, reason);
            }

            // 2) Evaluate preconditions in the KG
            var check = await _preconditions.EvaluateAllAsync(subjectLabel, subjectId!, binding.Preconditions!, ct);
            if (!check.Ok)
            {
                await AuditAsync(toolName, "RefusePreconditionFailed", check.Reason, subjectLabel, subjectId, sanitizedArgs, binding);
                return Refusal(toolName, sanitizedArgs, binding, subjectLabel, subjectId, check.Reason ?? "Precondition failed.");
            }
        }

        // 3) OK to proceed — include proposed effects for visibility
        await AuditAsync(toolName, "Proceed", null, subjectLabel, subjectId, sanitizedArgs, binding);
        return new PlanStep
        {
            Thought = $"Invoke tool '{toolName}' with validated preconditions.",
            ToolName = toolName,
            Arguments = args,
            Decision = PlanDecision.Proceed,
            ProposedEffects = binding.Effects?.Select(e => new
            {
                subject = e.Subject,
                property = e.Property,
                newValue = e.NewValue,
                label = e.Label
            }).Cast<object>().ToList(),
            SanitizedArgsJson = sanitizedArgs
        };
    }

    // ------------------------ helpers ------------------------

    private static string? FirstNonEmpty(IEnumerable<string?>? seq)
        => seq?.FirstOrDefault(s => !string.IsNullOrWhiteSpace(s));

    private static string? GuessSubjectFromEffects(ToolSchemaBinding binding)
        => FirstNonEmpty(binding.Effects?.Select(e => e.Subject));

    /// <summary>
    /// Heuristic: find an input field whose ontology @id matches the precondition's Subject (class).
    /// Return its value from args (converted to string).
    /// </summary>
    private static string? TryFindSubjectId(ToolSchemaBinding binding, string subjectLabel, IReadOnlyDictionary<string, object?> args)
    {
        if (binding.Input is null || binding.Input.Count == 0) return null;

        // Find first input field whose OntologyId equals the subject
        var kv = binding.Input.FirstOrDefault(x => string.Equals(x.Value.OntologyId, subjectLabel, StringComparison.Ordinal));
        if (kv.Key is not null && args.TryGetValue(kv.Key, out var val) && val is not null)
            return val.ToString();

        // Fallback: common "{label}Id" naming
        var fallbackKey = $"{TrimPrefix(subjectLabel)}Id";
        if (args.TryGetValue(fallbackKey, out var v2) && v2 is not null)
            return v2.ToString();

        return null;
    }

    private static string TrimPrefix(string s)
    {
        // turn "ldm:Reservation" -> "Reservation"
        var i = Math.Max(s.LastIndexOf(':'), s.LastIndexOf('/'));
        return i >= 0 && i < s.Length - 1 ? s[(i + 1)..] : s;
    }

    private static JsonElement SanitizeArgs(IReadOnlyDictionary<string, object?> args)
    {
        var node = new JsonObject();
        foreach (var (k, v) in args)
        {
            if (LooksSensitive(k)) continue;
            node[k] = v is null ? null : JsonValue.Create(v);
        }
        using var doc = JsonDocument.Parse(node.ToJsonString());
        return doc.RootElement.Clone();
    }

    private static readonly string[] SensitiveKeys = ["password", "token", "secret", "apikey", "api_key", "authorization", "auth"];
    private static bool LooksSensitive(string key)
        => SensitiveKeys.Any(s => key.Contains(s, StringComparison.OrdinalIgnoreCase));

    private async Task AuditAsync(
        string toolName,
        string decision,
        string? reason,
        string? subjectLabel,
        string? subjectId,
        JsonElement? sanitizedArgs,
        ToolSchemaBinding binding)
    {
        try
        {
            var rec = new AuditRecord
            {
                ToolName = toolName,
                Decision = decision,
                Reason = reason,
                SubjectLabel = subjectLabel,
                SubjectId = subjectId,
                Arguments = sanitizedArgs,
                Preconditions = binding.Preconditions?.Select(p =>
                    $"{TrimPrefix(p.Subject ?? "")}:{TrimPrefix(p.Predicate ?? "")}=={p.Equals}").ToArray(),
                Effects = binding.Effects?.Select(e =>
                    $"{TrimPrefix(e.Subject)}.{TrimPrefix(e.Property)}→{e.NewValue}").ToArray()
            };
            await _audit.WriteAsync(rec);
        }
        catch (Exception ex)
        {
            _log.LogWarning(ex, "Audit write failed for tool {Tool}", toolName);
        }
    }

    private static PlanStep Refusal(
        string toolName,
        JsonElement? sanitizedArgs,
        ToolSchemaBinding binding,
        string? subjectLabel,
        string? subjectId,
        string reason)
        => new()
        {
            Thought = $"Do not invoke '{toolName}' because a precondition failed.",
            ToolName = toolName,
            Arguments = new Dictionary<string, object?>(), // avoid echoing raw args on refusal
            Decision = PlanDecision.RefusePreconditionFailed,
            RefusalReason = reason,
            ProposedEffects = binding.Effects?.Select(e => new
            {
                subject = e.Subject,
                property = e.Property,
                newValue = e.NewValue,
                label = e.Label
            }).Cast<object>().ToList(),
            SanitizedArgsJson = sanitizedArgs
        };
}
```

---

## How to wire the planner in your MCP server (stdio or HTTP)

Right before you execute a tool in `CallToolHandler`, insert the planner gate:

```csharp
// assuming DI has: SimplePlanner, PreconditionsEvaluator, GraphStore, LoggingAuditSink
builder.Services.AddScoped<IPlanner, SimplePlanner>();
builder.Services.AddScoped<IAuditSink, LoggingAuditSink>();

// In CallToolHandler:
CallToolHandler = async (request, ct) =>
{
    using var scope = app.Services.CreateScope();

    var registry = scope.ServiceProvider.GetRequiredService<IDictionary<string, ToolSchemaBinding>>(); // however you keep bindings
    var planner  = scope.ServiceProvider.GetRequiredService<IPlanner>();

    var name = request.Params?.Name ?? throw new McpException("Tool name required");
    if (!registry.TryGetValue(name, out var binding))
        throw new McpException($"Unknown tool: {name}");

    var args = request.Params?.Arguments?.ToDictionary(kv => kv.Key, kv => kv.Value) ?? new();

    // 1) Plan + precondition gate
    var plan = await planner.PlanAndAuthorizeAsync(binding, args, ct);
    if (plan.Decision != PlanDecision.Proceed)
    {
        var refusal = new { status = "refused", reason = plan.RefusalReason, tool = name };
        return new CallToolResult { Content = [ new TextContentBlock { Type="text", Text = System.Text.Json.JsonSerializer.Serialize(refusal) } ] };
    }

    // 2) Proceed to your actual tool invocation
    // ... run the tool implementation and return its result ...
}
```

---

### Why this meets Milestone 5

* **Typed ReAct**: The `PlanStep` models the Thought/Action/Observation loop (thin slice).
* **Precondition gate**: Uses `PreconditionsEvaluator` over the KG before any side effects.
* **Audit**: Every decision (“Proceed” or “Refuse”) is logged via `IAuditSink`.
* **Ontology-first**: Subject resolution is **ontology-bound** using `ToolSchemaBinding.Input[*].OntologyId` matching each precondition’s `Subject`.

If you want, I can also add a **Postgres-backed `AuditSink`** (EF entity + `AuditDbContext`) so these records show up in your Blazor Operator Console.


---

Perfect — here’s a **Postgres-backed `AuditSink`** you can paste in as the next section. It’s PR-ready and deliberately mirrors your EF/Postgres style from the persistence baseline (no migrations generated here).

It includes:

* A new project: **`src/LimboDancer.MCP.Audit`**
* `AuditDbContext` + EF entity `AuditRecordEntity`
* `PostgresAuditSink` implementing your `IAuditSink`
* A small read API (`IAuditReadStore`) for the Blazor Operator Console
* DI wiring helpers
* (Optional) a tiny Blazor page to render the audit stream

---

## Project

**`src/LimboDancer.MCP.Audit/LimboDancer.MCP.Audit.csproj`**

```xml
<Project Sdk="Microsoft.NET.Sdk">
  <PropertyGroup>
    <TargetFramework>net9.0</TargetFramework>
    <Nullable>enable</Nullable>
    <ImplicitUsings>enable</ImplicitUsings>
  </PropertyGroup>

  <ItemGroup>
    <PackageReference Include="Microsoft.EntityFrameworkCore" Version="9.0.0" />
    <PackageReference Include="Microsoft.EntityFrameworkCore.Relational" Version="9.0.0" />
    <PackageReference Include="Npgsql.EntityFrameworkCore.PostgreSQL" Version="9.0.0" />
    <PackageReference Include="Microsoft.Extensions.Options.ConfigurationExtensions" Version="9.0.0" />
    <PackageReference Include="Microsoft.EntityFrameworkCore.Design" Version="9.0.0">
      <PrivateAssets>all</PrivateAssets>
    </PackageReference>
  </ItemGroup>

  <ItemGroup>
    <ProjectReference Include="..\LimboDancer.MCP.Core\LimboDancer.MCP.Core.csproj" />
  </ItemGroup>
</Project>
```

---

## EF model

**`src/LimboDancer.MCP.Audit/Entities.cs`**

```csharp
using System.Text.Json;

namespace LimboDancer.MCP.Audit;

public sealed class AuditRecordEntity
{
    public Guid Id { get; set; }                // maps Planner.AuditRecord.Id
    public DateTime TimestampUtc { get; set; }  // UTC

    public string ToolName { get; set; } = "";
    public string Decision { get; set; } = "";  // e.g., Proceed, RefusePreconditionFailed
    public string? Reason { get; set; }

    public string? SubjectLabel { get; set; }
    public string? SubjectId { get; set; }

    public JsonDocument? Arguments { get; set; }      // jsonb
    public JsonDocument? Preconditions { get; set; }  // jsonb (string[])
    public JsonDocument? Effects { get; set; }        // jsonb (string[])

    // Optional correlation fields you may fill in later
    public string? CorrelationId { get; set; }
    public string? ActorId { get; set; }              // user / agent identity if known
}
```

**`src/LimboDancer.MCP.Audit/AuditDbContext.cs`**

```csharp
using Microsoft.EntityFrameworkCore;

namespace LimboDancer.MCP.Audit;

public sealed class AuditDbContext : DbContext
{
    public DbSet<AuditRecordEntity> AuditRecords => Set<AuditRecordEntity>();
    public AuditDbContext(DbContextOptions<AuditDbContext> options) : base(options) { }

    protected override void OnModelCreating(ModelBuilder b)
    {
        b.HasPostgresExtension("uuid-ossp");

        b.Entity<AuditRecordEntity>(e =>
        {
            e.ToTable("audit_records");
            e.HasKey(x => x.Id);
            e.Property(x => x.Id).ValueGeneratedNever();

            e.Property(x => x.TimestampUtc)
             .HasColumnType("timestamptz")
             .HasDefaultValueSql("now() at time zone 'utc'");

            e.Property(x => x.ToolName).HasMaxLength(200).IsRequired();
            e.Property(x => x.Decision).HasMaxLength(100).IsRequired();
            e.Property(x => x.Reason).HasColumnType("text");

            e.Property(x => x.SubjectLabel).HasMaxLength(200);
            e.Property(x => x.SubjectId).HasMaxLength(200);

            e.Property(x => x.Arguments).HasColumnType("jsonb");
            e.Property(x => x.Preconditions).HasColumnType("jsonb");
            e.Property(x => x.Effects).HasColumnType("jsonb");

            e.Property(x => x.CorrelationId).HasMaxLength(200);
            e.Property(x => x.ActorId).HasMaxLength(200);

            e.HasIndex(x => x.TimestampUtc);
            e.HasIndex(x => new { x.ToolName, x.TimestampUtc });
            e.HasIndex(x => new { x.Decision, x.TimestampUtc });
        });
    }
}
```

---

## Options + DI

**`src/LimboDancer.MCP.Audit/AuditOptions.cs`**

```csharp
namespace LimboDancer.MCP.Audit;

public sealed class AuditOptions
{
    public string ConnectionString { get; set; } = "";
    public bool ApplyMigrationsAtStartup { get; set; } = false; // keep false if CI handles migrations
}
```

**`src/LimboDancer.MCP.Audit/ServiceCollectionExtensions.cs`**

```csharp
using Microsoft.EntityFrameworkCore;
using Microsoft.Extensions.Configuration;
using Microsoft.Extensions.DependencyInjection;
using Microsoft.Extensions.Hosting;

namespace LimboDancer.MCP.Audit;

public static class ServiceCollectionExtensions
{
    public static IServiceCollection AddAuditStore(this IServiceCollection services, IConfiguration config)
    {
        var section = config.GetSection("Audit");
        services.Configure<AuditOptions>(section);
        var opts = section.Get<AuditOptions>() ?? new AuditOptions();

        services.AddDbContext<AuditDbContext>(db =>
            db.UseNpgsql(opts.ConnectionString));

        services.AddScoped<IAuditReadStore, AuditReadStore>();
        services.AddScoped<IAuditSink, PostgresAuditSink>(); // ← implement below

        return services;
    }

    public static async Task InitializeAuditAsync(this IServiceProvider sp, CancellationToken ct = default)
    {
        using var scope = sp.CreateScope();
        var ctx = scope.ServiceProvider.GetRequiredService<AuditDbContext>();
        var env = scope.ServiceProvider.GetRequiredService<IHostEnvironment>();
        var opts = scope.ServiceProvider.GetRequiredService<Microsoft.Extensions.Options.IOptions<AuditOptions>>().Value;

        if (opts.ApplyMigrationsAtStartup)
            await ctx.Database.MigrateAsync(ct);

        await ctx.Database.CanConnectAsync(ct);
    }
}
```

---

## `IAuditSink` implementation (writes to Postgres)

**`src/LimboDancer.MCP.Audit/PostgresAuditSink.cs`**

```csharp
using System.Text.Json;
using LimboDancer.MCP.Core.Planning;
using Microsoft.EntityFrameworkCore;

namespace LimboDancer.MCP.Audit;

public sealed class PostgresAuditSink : IAuditSink
{
    private readonly AuditDbContext _db;
    public PostgresAuditSink(AuditDbContext db) => _db = db;

    public async Task WriteAsync(AuditRecord record, CancellationToken ct = default)
    {
        var entity = new AuditRecordEntity
        {
            Id = record.Id,
            TimestampUtc = record.TimestampUtc,
            ToolName = record.ToolName,
            Decision = record.Decision,
            Reason = record.Reason,
            SubjectLabel = record.SubjectLabel,
            SubjectId = record.SubjectId,
            Arguments = record.Arguments?.Clone(), // JsonElement -> JsonDocument
            Preconditions = record.Preconditions is null ? null : JsonDocument.Parse(JsonSerializer.Serialize(record.Preconditions)),
            Effects = record.Effects is null ? null : JsonDocument.Parse(JsonSerializer.Serialize(record.Effects)),
            // Correlation/Actor can be set by caller later via extended AuditRecord
            CorrelationId = null,
            ActorId = null
        };

        _db.AuditRecords.Add(entity);
        await _db.SaveChangesAsync(ct);
    }
}
```

> `record.Arguments?.Clone()` returns a `JsonElement`; `.Clone()` keeps it alive. EF needs a `JsonDocument`; the code uses the implicit conversion available when assigning a `JsonElement?` to `JsonDocument?` **won’t** compile — so we wrap:
> Replace the assignment with:
>
> ```csharp
> Arguments = record.Arguments is null ? null : JsonDocument.Parse(record.Arguments.Value.GetRawText()),
> ```
>
> (Use that line if your compiler complains.)

---

## Read API for the console

**`src/LimboDancer.MCP.Audit/IAuditReadStore.cs`**

```csharp
namespace LimboDancer.MCP.Audit;

public interface IAuditReadStore
{
    Task<IReadOnlyList<AuditRow>> GetRecentAsync(
        int take = 100,
        string? toolName = null,
        string? decision = null,
        DateTime? sinceUtc = null,
        CancellationToken ct = default);
}

public sealed record AuditRow(
    Guid Id,
    DateTime TimestampUtc,
    string ToolName,
    string Decision,
    string? Reason,
    string? SubjectLabel,
    string? SubjectId,
    string? ArgumentsJson,
    string? PreconditionsJson,
    string? EffectsJson);
```

**`src/LimboDancer.MCP.Audit/AuditReadStore.cs`**

```csharp
using Microsoft.EntityFrameworkCore;

namespace LimboDancer.MCP.Audit;

public sealed class AuditReadStore : IAuditReadStore
{
    private readonly AuditDbContext _db;
    public AuditReadStore(AuditDbContext db) => _db = db;

    public async Task<IReadOnlyList<AuditRow>> GetRecentAsync(
        int take = 100,
        string? toolName = null,
        string? decision = null,
        DateTime? sinceUtc = null,
        CancellationToken ct = default)
    {
        take = Math.Clamp(take, 1, 1000);

        var q = _db.AuditRecords.AsNoTracking();

        if (!string.IsNullOrWhiteSpace(toolName))
            q = q.Where(x => x.ToolName == toolName);

        if (!string.IsNullOrWhiteSpace(decision))
            q = q.Where(x => x.Decision == decision);

        if (sinceUtc is not null)
            q = q.Where(x => x.TimestampUtc >= sinceUtc);

        q = q.OrderByDescending(x => x.TimestampUtc).Take(take);

        var rows = await q
            .Select(x => new AuditRow(
                x.Id,
                x.TimestampUtc,
                x.ToolName,
                x.Decision,
                x.Reason,
                x.SubjectLabel,
                x.SubjectId,
                x.Arguments != null ? x.Arguments.RootElement.GetRawText() : null,
                x.Preconditions != null ? x.Preconditions.RootElement.GetRawText() : null,
                x.Effects != null ? x.Effects.RootElement.GetRawText() : null))
            .ToListAsync(ct);

        return rows;
    }
}
```

---

## App settings and DI

Add to your **HTTP server** (or shared host) `appsettings.*`:

```json
{
  "Audit": {
    "ConnectionString": "Host=localhost;Port=5432;Database=limbodancer_audit;Username=postgres;Password=postgres",
    "ApplyMigrationsAtStartup": false
  }
}
```

Wire in **Program.cs** (HTTP MCP server):

```csharp
using LimboDancer.MCP.Audit;

// ...
builder.Services.AddAuditStore(builder.Configuration);

// Optional init (if not using CI migrations)
 // await app.Services.InitializeAuditAsync();
```

To switch the planner to DB-backed sink, register **after** adding the audit store:

```csharp
// Replace the logging sink with Postgres sink (AddAuditStore already registers IAuditSink)
builder.Services.AddScoped<IAuditSink, PostgresAuditSink>();
```

---

## (Optional) Blazor Operator Console page

**`src/LimboDancer.MCP.BlazorConsole/Pages/Audit.razor`**

```razor
@page "/audit"
@inject LimboDancer.MCP.Audit.IAuditReadStore Audit

<h1 class="text-2xl font-semibold mb-4">Audit</h1>

<div class="flex gap-2 items-end mb-4">
  <input @bind="toolFilter" class="border rounded px-2 py-1" placeholder="Tool name (optional)" />
  <select @bind="decisionFilter" class="border rounded px-2 py-1">
    <option value="">All decisions</option>
    <option>Proceed</option>
    <option>RefusePreconditionFailed</option>
    <option>RefuseUnsupported</option>
  </select>
  <input type="number" @bind="take" class="border rounded px-2 py-1 w-24" />
  <button class="border rounded px-3 py-1" @onclick="Reload">Load</button>
</div>

@if (rows is null)
{
  <p>Loading…</p>
}
else if (rows.Count == 0)
{
  <p>No audit records.</p>
}
else
{
  <table class="min-w-full text-sm">
    <thead>
      <tr class="text-left border-b">
        <th class="py-2 pr-4">Time (UTC)</th>
        <th class="py-2 pr-4">Tool</th>
        <th class="py-2 pr-4">Decision</th>
        <th class="py-2 pr-4">Subject</th>
        <th class="py-2 pr-4">Reason</th>
        <th class="py-2 pr-4">Details</th>
      </tr>
    </thead>
    <tbody>
      @foreach (var r in rows)
      {
        <tr class="border-b align-top">
          <td class="py-2 pr-4">@r.TimestampUtc.ToString("u")</td>
          <td class="py-2 pr-4">@r.ToolName</td>
          <td class="py-2 pr-4">@r.Decision</td>
          <td class="py-2 pr-4">@($"{r.SubjectLabel}/{r.SubjectId}")</td>
          <td class="py-2 pr-4">@r.Reason</td>
          <td class="py-2 pr-4">
            <details>
              <summary class="cursor-pointer">JSON</summary>
              <pre class="whitespace-pre-wrap text-xs">
Arguments: @r.ArgumentsJson
Preconditions: @r.PreconditionsJson
Effects: @r.EffectsJson
              </pre>
            </details>
          </td>
        </tr>
      }
    </tbody>
  </table>
}

@code {
  private List<LimboDancer.MCP.Audit.AuditRow>? rows;
  private string? toolFilter;
  private string? decisionFilter;
  private int take = 100;

  protected override async Task OnInitializedAsync() => await Reload();

  private async Task Reload()
  {
    rows = (await Audit.GetRecentAsync(take, toolFilter, decisionFilter, sinceUtc: null)).ToList();
  }
}
```

Register the read store in the Blazor app’s DI (usually already available if you register `AddAuditStore` in the host; if the console is a separate process, also add):

```csharp
// Blazor Console Program.cs
using LimboDancer.MCP.Audit;
builder.Services.AddAuditStore(builder.Configuration);
```

---

### Done

* Planner now writes auditable decisions to Postgres via `PostgresAuditSink`.
* Console has a simple view to inspect activity.
* No migrations are included (EF tooling/CI can generate/apply them).
