# Persistence baseline (EF Core - Postgres)

Perfect—here’s a **PR-ready persistence baseline** for **EF Core + PostgreSQL**. It defines the three core entities, a DbContext, DI wiring, and a minimal store for appending/reading chat history. (Per your note, I’m not generating migrations.)

---

## 1) Storage project

### `src/LimboDancer.MCP.Storage/LimboDancer.MCP.Storage.csproj`

```xml
<Project Sdk="Microsoft.NET.Sdk">
  <PropertyGroup>
    <TargetFramework>net9.0</TargetFramework>
    <Nullable>enable</Nullable>
    <ImplicitUsings>enable</ImplicitUsings>
  </PropertyGroup>

  <ItemGroup>
    <PackageReference Include="Microsoft.EntityFrameworkCore" Version="9.0.0" />
    <PackageReference Include="Microsoft.EntityFrameworkCore.Relational" Version="9.0.0" />
    <PackageReference Include="Npgsql.EntityFrameworkCore.PostgreSQL" Version="9.0.0" />
    <PackageReference Include="Microsoft.Extensions.Options.ConfigurationExtensions" Version="9.0.0" />
    <!-- For design-time tooling (dotnet-ef); not needed at runtime -->
    <PackageReference Include="Microsoft.EntityFrameworkCore.Design" Version="9.0.0">
      <PrivateAssets>all</PrivateAssets>
    </PackageReference>
  </ItemGroup>

  <ItemGroup>
    <ProjectReference Include="..\LimboDancer.MCP.Core\LimboDancer.MCP.Core.csproj" />
  </ItemGroup>
</Project>
```

---

### `src/LimboDancer.MCP.Storage/Entities.cs`

```csharp
using System.Text.Json;

namespace LimboDancer.MCP.Storage;

// ER: Session, Message, MemoryItem
public sealed class Session
{
    public Guid Id { get; set; }            // UUID
    public string UserId { get; set; } = null!;
    public JsonDocument? TagsJson { get; set; }   // jsonb (optional)
    public DateTime CreatedAt { get; set; } // UTC

    public ICollection<Message> Messages { get; set; } = new List<Message>();
}

public enum MessageRole
{
    User,
    Assistant,
    Tool
}

public sealed class Message
{
    public Guid Id { get; set; }             // UUID
    public Guid SessionId { get; set; }      // FK
    public MessageRole Role { get; set; }
    public string Content { get; set; } = string.Empty; // TEXT
    public JsonDocument? ToolCallsJson { get; set; }    // jsonb (optional)
    public DateTime CreatedAt { get; set; }  // UTC

    public Session Session { get; set; } = null!;
}

public enum MemoryKind
{
    Vector,
    Graph,
    Reasoning
}

public sealed class MemoryItem
{
    public Guid Id { get; set; }                 // UUID
    public MemoryKind Kind { get; set; }
    public string ExternalId { get; set; } = ""; // e.g., vector id, graph node id
    public JsonDocument? MetaJson { get; set; }  // jsonb (ontology tags, etc.)
    public DateTime CreatedAt { get; set; }      // UTC
}
```

---

### `src/LimboDancer.MCP.Storage/ChatDbContext.cs`

```csharp
using Microsoft.EntityFrameworkCore;
using Npgsql;

namespace LimboDancer.MCP.Storage;

public sealed class ChatDbContext : DbContext
{
    public DbSet<Session> Sessions => Set<Session>();
    public DbSet<Message> Messages => Set<Message>();
    public DbSet<MemoryItem> MemoryItems => Set<MemoryItem>();

    public ChatDbContext(DbContextOptions<ChatDbContext> options) : base(options) {}

    protected override void OnModelCreating(ModelBuilder b)
    {
        // Global
        b.HasPostgresExtension("uuid-ossp");

        // Session
        b.Entity<Session>(e =>
        {
            e.ToTable("sessions");
            e.HasKey(x => x.Id);
            e.Property(x => x.Id).ValueGeneratedNever();
            e.Property(x => x.UserId).HasMaxLength(256).IsRequired();
            e.Property(x => x.TagsJson).HasColumnType("jsonb");
            e.Property(x => x.CreatedAt).HasColumnType("timestamptz")
              .HasDefaultValueSql("now() at time zone 'utc'");
            e.HasIndex(x => x.CreatedAt);
            e.HasMany(x => x.Messages).WithOne(m => m.Session).HasForeignKey(m => m.SessionId);
        });

        // Message
        b.Entity<Message>(e =>
        {
            e.ToTable("messages");
            e.HasKey(x => x.Id);
            e.Property(x => x.Id).ValueGeneratedNever();
            e.Property(x => x.Content).HasColumnType("text").IsRequired();
            e.Property(x => x.ToolCallsJson).HasColumnType("jsonb");
            e.Property(x => x.CreatedAt).HasColumnType("timestamptz")
              .HasDefaultValueSql("now() at time zone 'utc'");
            e.HasIndex(x => new { x.SessionId, x.CreatedAt });
            e.HasIndex(x => x.Role);
        });

        // MemoryItem
        b.Entity<MemoryItem>(e =>
        {
            e.ToTable("memory_items");
            e.HasKey(x => x.Id);
            e.Property(x => x.Id).ValueGeneratedNever();
            e.Property(x => x.ExternalId).HasMaxLength(256).IsRequired();
            e.Property(x => x.MetaJson).HasColumnType("jsonb");
            e.Property(x => x.CreatedAt).HasColumnType("timestamptz")
              .HasDefaultValueSql("now() at time zone 'utc'");
            e.HasIndex(x => new { x.Kind, x.CreatedAt });
            e.HasIndex(x => new { x.Kind, x.ExternalId }).IsUnique(false);
        });
    }
}
```

---

### `src/LimboDancer.MCP.Storage/StorageOptions.cs`

```csharp
namespace LimboDancer.MCP.Storage;

public sealed class StorageOptions
{
    // e.g. "Host=...;Port=5432;Database=limbodancer;Username=...;Password=..."
    public string ConnectionString { get; set; } = "";
    public bool ApplyMigrationsAtStartup { get; set; } = false; // leave off unless you want auto-apply
}
```

---

### `src/LimboDancer.MCP.Storage/ServiceCollectionExtensions.cs`

```csharp
using Microsoft.EntityFrameworkCore;
using Microsoft.Extensions.Configuration;
using Microsoft.Extensions.DependencyInjection;
using Microsoft.Extensions.Hosting;

namespace LimboDancer.MCP.Storage;

public static class ServiceCollectionExtensions
{
    public static IServiceCollection AddPersistence(this IServiceCollection services, IConfiguration config)
    {
        var section = config.GetSection("Persistence");
        services.Configure<StorageOptions>(section);
        var opts = section.Get<StorageOptions>() ?? new StorageOptions();

        services.AddDbContext<ChatDbContext>(db =>
        {
            db.UseNpgsql(opts.ConnectionString, npg =>
            {
                // keep for future: npg.EnableRetryOnFailure();
            });
        });

        // Minimal repositories / stores
        services.AddScoped<IChatHistoryStore, ChatHistoryStore>();

        return services;
    }

    /// <summary>
    /// Optionally apply migrations and verify connectivity at startup.
    /// </summary>
    public static async Task InitializePersistenceAsync(this IServiceProvider sp, CancellationToken ct = default)
    {
        using var scope = sp.CreateScope();
        var ctx = scope.ServiceProvider.GetRequiredService<ChatDbContext>();
        var env = scope.ServiceProvider.GetRequiredService<IHostEnvironment>();
        var opts = scope.ServiceProvider.GetRequiredService<Microsoft.Extensions.Options.IOptions<StorageOptions>>().Value;

        if (opts.ApplyMigrationsAtStartup)
        {
            await ctx.Database.MigrateAsync(ct);
        }

        // Warm up connection
        await ctx.Database.CanConnectAsync(ct);
    }
}
```

---

## 2) Minimal store abstraction

### `src/LimboDancer.MCP.Core/Abstractions/IChatHistoryStore.cs`

```csharp
using LimboDancer.MCP.Storage;
using System.Text.Json;

namespace LimboDancer.MCP.Core;

public interface IChatHistoryStore
{
    Task<Session> CreateSessionAsync(string userId, JsonDocument? tagsJson = null, CancellationToken ct = default);
    Task<Message> AppendMessageAsync(Guid sessionId, MessageRole role, string content, JsonDocument? toolCallsJson = null, CancellationToken ct = default);
    Task<IReadOnlyList<Message>> GetMessagesAsync(Guid sessionId, int take = 100, int skip = 0, CancellationToken ct = default);
}
```

---

### `src/LimboDancer.MCP.Storage/Repositories/ChatHistoryStore.cs`

```csharp
using System.Text.Json;
using LimboDancer.MCP.Core;
using Microsoft.EntityFrameworkCore;

namespace LimboDancer.MCP.Storage;

public sealed class ChatHistoryStore : IChatHistoryStore
{
    private readonly ChatDbContext _db;

    public ChatHistoryStore(ChatDbContext db) => _db = db;

    public async Task<Session> CreateSessionAsync(string userId, JsonDocument? tagsJson = null, CancellationToken ct = default)
    {
        var s = new Session
        {
            Id = Guid.NewGuid(),
            UserId = userId,
            TagsJson = tagsJson,
            CreatedAt = DateTime.UtcNow
        };
        _db.Sessions.Add(s);
        await _db.SaveChangesAsync(ct);
        return s;
    }

    public async Task<Message> AppendMessageAsync(Guid sessionId, MessageRole role, string content, JsonDocument? toolCallsJson = null, CancellationToken ct = default)
    {
        // ensure session exists (cheap)
        var exists = await _db.Sessions.AsNoTracking().AnyAsync(x => x.Id == sessionId, ct);
        if (!exists) throw new InvalidOperationException($"Session {sessionId} not found.");

        var m = new Message
        {
            Id = Guid.NewGuid(),
            SessionId = sessionId,
            Role = role,
            Content = content,
            ToolCallsJson = toolCallsJson,
            CreatedAt = DateTime.UtcNow
        };
        _db.Messages.Add(m);
        await _db.SaveChangesAsync(ct);
        return m;
    }

    public async Task<IReadOnlyList<Message>> GetMessagesAsync(Guid sessionId, int take = 100, int skip = 0, CancellationToken ct = default)
    {
        take = Math.Clamp(take, 1, 1000);
        skip = Math.Max(0, skip);

        var items = await _db.Messages.AsNoTracking()
            .Where(x => x.SessionId == sessionId)
            .OrderBy(x => x.CreatedAt)
            .Skip(skip)
            .Take(take)
            .ToListAsync(ct);

        return items;
    }
}
```

---

## 3) Settings and usage

### `src/LimboDancer.MCP.McpServer.Http/appsettings.Development.json`

```json
{
  "Persistence": {
    "ConnectionString": "Host=localhost;Port=5432;Database=limbodancer_dev;Username=postgres;Password=postgres",
    "ApplyMigrationsAtStartup": false
  }
}
```

> In **ACA**, set `Persistence__ConnectionString` via secrets/env and keep `ApplyMigrationsAtStartup` false if migrations run in CI.

---

### Wire-up example (HTTP server Program.cs)

```csharp
// using LimboDancer.MCP.Storage;
var builder = WebApplication.CreateBuilder(args);

// add config providers as you like (KeyVault, env, etc.)
builder.Services.AddPersistence(builder.Configuration);

var app = builder.Build();

// Optionally: await app.Services.InitializePersistenceAsync();

app.MapGet("/healthz/db", async (ChatDbContext db, CancellationToken ct) =>
{
    var ok = await db.Database.CanConnectAsync(ct);
    return ok ? Results.Ok("ok") : Results.Problem("db not reachable");
});

app.Run();
```

---

## 4) Notes / conventions

* **Timestamps**: all `timestamptz`, defaulting to UTC on the server.
* **IDs**: app-assigned `Guid.NewGuid()`; EF configured as `ValueGeneratedNever()`.
* **JSON**: `JsonDocument` mapped to Postgres **jsonb** for `TagsJson`, `ToolCallsJson`, `MetaJson`.
* **Indexes**: by time and common access paths (`SessionId, CreatedAt`, `Kind, CreatedAt`, etc.).
* **No migrations included**: your automation can scaffold/apply them (the csproj includes design-time package to support `dotnet ef` if needed).

If you want, I can next generate the **Azure AI Search vector index + client** (Milestone 3) with ontology-aware filter fields (`class`, `uri`, `tags`) and a tiny ingest sample.
