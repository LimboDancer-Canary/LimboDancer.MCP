# 3. **Cosmos Gremlin graph scaffold**

   * Files: `src/LimboDancer.MCP.Graph.CosmosGremlin/{GremlinClientFactory.cs, GraphStore.cs, Preconditions.cs, Effects.cs}`.
   * Implement upsert of vertices/edges for core classes (Person, Trip, Reservation, Tool/Skill) and helpers to evaluate preconditions/effects.
   * Why: It’s called out as a core library and feeds the precondition/effect path. &#x20;


---

Awesome — here’s a **PR-ready Cosmos Gremlin scaffold** for the knowledge graph.
It gives you:

* A **Gremlin client factory** tuned for Cosmos DB (GraphSON2, pooled sockets).
* A **GraphStore** with safe **upsert** of vertices/edges for core labels (Person, Trip, Reservation, Tool, Skill) and generic helpers.
* **Precondition** evaluators that consume your ontology `ToolPrecondition`.
* **Effect** appliers that consume your ontology `ToolEffect`.

> These snippets assume your ontology constants (`Ldm`, `Kg`) live in `LimboDancer.MCP.Ontology` (as we created earlier).

---

## `src/LimboDancer.MCP.Graph.CosmosGremlin/LimboDancer.MCP.Graph.CosmosGremlin.csproj`

```xml
<Project Sdk="Microsoft.NET.Sdk">
  <PropertyGroup>
    <TargetFramework>net9.0</TargetFramework>
    <Nullable>enable</Nullable>
    <ImplicitUsings>enable</ImplicitUsings>
  </PropertyGroup>

  <ItemGroup>
    <PackageReference Include="Gremlin.Net" Version="3.6.5" />
  </ItemGroup>

  <ItemGroup>
    <ProjectReference Include="..\LimboDancer.MCP.Ontology\LimboDancer.MCP.Ontology.csproj" />
  </ItemGroup>
</Project>
```

---

## `src/LimboDancer.MCP.Graph.CosmosGremlin/GremlinClientFactory.cs`

```csharp
using System;
using System.Net.WebSockets;
using Gremlin.Net.Driver;
using Gremlin.Net.Driver.Messages;
using Gremlin.Net.Structure.IO.GraphSON;

namespace LimboDancer.MCP.Graph.CosmosGremlin;

public sealed class GremlinOptions
{
    /// <summary>E.g. "youracct.gremlin.cosmos.azure.com"</summary>
    public string Host { get; set; } = "";
    public int Port { get; set; } = 443;

    /// <summary>Cosmos DB database id.</summary>
    public string Database { get; set; } = "";
    /// <summary>Graph (container) id.</summary>
    public string Graph { get; set; } = "";

    /// <summary>Cosmos DB account key (primary/secondary). Used as password.</summary>
    public string PrimaryKey { get; set; } = "";

    /// <summary>Pool size per process. Default 4.</summary>
    public int PoolSize { get; set; } = 4;

    /// <summary>Max in-process requests per connection. Default 32.</summary>
    public int MaxInProcessPerConnection { get; set; } = 32;

    public TimeSpan KeepAlive { get; set; } = TimeSpan.FromSeconds(10);
}

public static class GremlinClientFactory
{
    /// <summary>
    /// Cosmos DB Gremlin requires:
    /// - SSL enabled
    /// - username "/dbs/{db}/colls/{graph}"
    /// - password = account key
    /// - GraphSON2 serializer (most compatible)
    /// </summary>
    public static GremlinClient Create(GremlinOptions opts)
    {
        ArgumentNullException.ThrowIfNull(opts);
        if (string.IsNullOrWhiteSpace(opts.Host)) throw new ArgumentException("Host required", nameof(opts.Host));
        if (string.IsNullOrWhiteSpace(opts.Database)) throw new ArgumentException("Database required", nameof(opts.Database));
        if (string.IsNullOrWhiteSpace(opts.Graph)) throw new ArgumentException("Graph required", nameof(opts.Graph));
        if (string.IsNullOrWhiteSpace(opts.PrimaryKey)) throw new ArgumentException("PrimaryKey required", nameof(opts.PrimaryKey));

        var server = new GremlinServer(
            hostname: opts.Host,
            port: opts.Port,
            enableSsl: true,
            username: $"/dbs/{opts.Database}/colls/{opts.Graph}",
            password: opts.PrimaryKey);

        var pool = new ConnectionPoolSettings
        {
            MaxInProcessPerConnection = opts.MaxInProcessPerConnection,
            PoolSize = opts.PoolSize,
            ReconnectionAttempts = 4,
            ReconnectionBaseDelay = TimeSpan.FromSeconds(1)
        };

        // Cosmos Gremlin commonly expects GraphSON2
        var serializer = new GraphSON2MessageSerializer();

        var ws = new Action<ClientWebSocketOptions>(o =>
        {
            o.KeepAliveInterval = opts.KeepAlive;
        });

        return new GremlinClient(server, serializer, pool, ws, new RequestMessageSerializer());
    }
}
```

---

## `src/LimboDancer.MCP.Graph.CosmosGremlin/GraphStore.cs`

```csharp
using System;
using System.Collections.Generic;
using System.Linq;
using System.Threading;
using System.Threading.Tasks;
using Gremlin.Net.Driver;
using Gremlin.Net.Process.Traversal;
using Gremlin.Net.Structure;
using LimboDancer.MCP.Ontology;

namespace LimboDancer.MCP.Graph.CosmosGremlin;

public sealed class GraphStore
{
    private readonly GremlinClient _client;

    public GraphStore(GremlinClient client) => _client = client ?? throw new ArgumentNullException(nameof(client));

    // ------------------------ Upserts (generic) ------------------------

    public async Task UpsertVertexAsync(string id, string label, IDictionary<string, object?> properties, CancellationToken ct = default)
    {
        var bindings = new Dictionary<string, object?>
        {
            ["id"] = id,
            ["label"] = label
        };

        var propsSequence = "";
        int i = 0;
        foreach (var kv in properties.Where(kv => kv.Value is not null))
        {
            var k = kv.Key;
            var pName = $"p{i++}";
            bindings[pName] = kv.Value;
            // .property('k', pN)
            propsSequence += $".property('{k}', {pName})";
        }

        var gremlin = "g.V(id).fold()" +
                      ".coalesce(unfold(), addV(label).property(id, id))" +
                      propsSequence;

        await _client.SubmitAsync<dynamic>(gremlin, bindings, cancellationToken: ct);
    }

    public async Task UpsertEdgeAsync(string outId, string label, string inId, IDictionary<string, object?>? properties = null, CancellationToken ct = default)
    {
        var bindings = new Dictionary<string, object?>
        {
            ["outId"] = outId,
            ["inId"]  = inId,
            ["label"] = label
        };

        var propsSequence = "";
        if (properties is not null)
        {
            int i = 0;
            foreach (var kv in properties.Where(kv => kv.Value is not null))
            {
                var k = kv.Key;
                var pName = $"p{i++}";
                bindings[pName] = kv.Value;
                propsSequence += $".property('{k}', {pName})";
            }
        }

        var gremlin =
            "g.V(outId).as('a')" +
            ".V(inId).as('b')" +
            ".coalesce(" +
                "select('a').outE(label).where(inV().hasId(inId))," +
                "addE(label).from('a').to('b')" +
            $"){propsSequence}";

        await _client.SubmitAsync<dynamic>(gremlin, bindings, cancellationToken: ct);
    }

    public async Task SetVertexPropertyAsync(string id, string propertyKey, object? value, CancellationToken ct = default)
    {
        var bindings = new Dictionary<string, object?>
        {
            ["id"] = id,
            ["k"]  = propertyKey,
            ["v"]  = value
        };
        var gremlin = "g.V(id).property(k, v)";
        await _client.SubmitAsync<dynamic>(gremlin, bindings, cancellationToken: ct);
    }

    // ------------------------ Convenience for core labels ------------------------

    public Task UpsertPersonAsync(string id, string? label = null, IDictionary<string, object?>? props = null, CancellationToken ct = default)
        => UpsertVertexAsync(id, Kg.Labels.Person, props ?? DefaultProps(label), ct);

    public Task UpsertTripAsync(string id, string? label = null, IDictionary<string, object?>? props = null, CancellationToken ct = default)
        => UpsertVertexAsync(id, Kg.Labels.Trip, props ?? DefaultProps(label), ct);

    public Task UpsertReservationAsync(string id, string? status = null, string? label = null, IDictionary<string, object?>? props = null, CancellationToken ct = default)
    {
        props ??= new Dictionary<string, object?>();
        if (!string.IsNullOrEmpty(label)) props[Kg.Fields.Label] = label;
        if (!string.IsNullOrEmpty(status)) props[Kg.Fields.Status] = status;
        return UpsertVertexAsync(id, Kg.Labels.Reservation, props, ct);
    }

    public Task UpsertToolAsync(string id, string? label = null, IDictionary<string, object?>? props = null, CancellationToken ct = default)
        => UpsertVertexAsync(id, Kg.Labels.Tool, props ?? DefaultProps(label), ct);

    public Task UpsertSkillAsync(string id, string? label = null, IDictionary<string, object?>? props = null, CancellationToken ct = default)
        => UpsertVertexAsync(id, Kg.Labels.Skill, props ?? DefaultProps(label), ct);

    public Task UpsertEdgeOwnsAsync(string personId, string reservationId, IDictionary<string, object?>? props = null, CancellationToken ct = default)
        => UpsertEdgeAsync(personId, Kg.Labels.Owns, reservationId, props, ct);

    public Task UpsertEdgeForTripAsync(string reservationId, string tripId, IDictionary<string, object?>? props = null, CancellationToken ct = default)
        => UpsertEdgeAsync(reservationId, Kg.Labels.ForTrip, tripId, props, ct);

    public Task UpsertEdgeRequiresAsync(string toolId, string skillId, IDictionary<string, object?>? props = null, CancellationToken ct = default)
        => UpsertEdgeAsync(toolId, Kg.Labels.Requires, skillId, props, ct);

    private static Dictionary<string, object?> DefaultProps(string? label)
    {
        var d = new Dictionary<string, object?>();
        if (!string.IsNullOrWhiteSpace(label)) d[Kg.Fields.Label] = label;
        return d;
    }

    // ------------------------ Simple reads for checks ------------------------

    public async Task<string?> GetVertexPropertyAsync(string id, string propertyKey, CancellationToken ct = default)
    {
        var gremlin = "g.V(id).values(k).limit(1)";
        var bindings = new Dictionary<string, object?> { ["id"] = id, ["k"] = propertyKey };
        var result = await _client.SubmitAsync<string>(gremlin, bindings, cancellationToken: ct);
        return result.FirstOrDefault();
    }

    public async Task<bool> EdgeExistsAsync(string outId, string label, string inId, CancellationToken ct = default)
    {
        var gremlin = "g.V(outId).outE(label).where(inV().hasId(inId)).limit(1).count()";
        var bindings = new Dictionary<string, object?> { ["outId"] = outId, ["label"] = label, ["inId"] = inId };
        var result = await _client.SubmitAsync<long>(gremlin, bindings, cancellationToken: ct);
        return result.FirstOrDefault() > 0;
    }
}
```

---

## `src/LimboDancer.MCP.Graph.CosmosGremlin/Preconditions.cs`

```csharp
using System;
using System.Collections.Generic;
using System.Linq;
using System.Threading;
using System.Threading.Tasks;
using LimboDancer.MCP.Ontology;

namespace LimboDancer.MCP.Graph.CosmosGremlin;

public sealed class PreconditionCheckResult
{
    public bool Ok { get; init; }
    public string? Reason { get; init; }

    public static PreconditionCheckResult Pass() => new() { Ok = true };
    public static PreconditionCheckResult Fail(string reason) => new() { Ok = false, Reason = reason };
}

/// <summary>
/// Evaluates ontology-bound ToolPreconditions against the graph.
/// </summary>
public sealed class PreconditionsEvaluator
{
    private readonly GraphStore _graph;

    public PreconditionsEvaluator(GraphStore graph) => _graph = graph;

    /// <summary>
    /// Evaluate a single precondition for a specific subject instance.
    /// Example: subjectLabel="Reservation", subjectId="R123".
    /// </summary>
    public async Task<PreconditionCheckResult> EvaluateAsync(
        string subjectLabel,
        string subjectId,
        ToolPrecondition p,
        CancellationToken ct = default)
    {
        // "exists" style if no predicate/value provided
        if (string.IsNullOrWhiteSpace(p.Predicate) && string.IsNullOrWhiteSpace(p.Equals))
        {
            // existence check -> any property, but simplest: ensure vertex exists (via a quick probe)
            var status = await _graph.GetVertexPropertyAsync(subjectId, Kg.Fields.Label, ct);
            return string.IsNullOrEmpty(status)
                ? PreconditionCheckResult.Fail($"Subject {subjectLabel}/{subjectId} not found.")
                : PreconditionCheckResult.Pass();
        }

        // Map ontology property to graph property key
        var propKey = MapPropertyKey(p.Predicate);
        if (!string.IsNullOrWhiteSpace(p.Equals))
        {
            var value = await _graph.GetVertexPropertyAsync(subjectId, propKey, ct);
            if (!string.Equals(value, p.Equals, StringComparison.OrdinalIgnoreCase))
                return PreconditionCheckResult.Fail($"Precondition failed: {propKey} != {p.Equals} (actual: {value ?? "<null>"})");
        }

        return PreconditionCheckResult.Pass();
    }

    /// <summary>
    /// Evaluate all preconditions; fails on first failure.
    /// </summary>
    public async Task<PreconditionCheckResult> EvaluateAllAsync(
        string subjectLabel,
        string subjectId,
        IEnumerable<ToolPrecondition> preconditions,
        CancellationToken ct = default)
    {
        foreach (var p in preconditions)
        {
            var r = await EvaluateAsync(subjectLabel, subjectId, p, ct);
            if (!r.Ok) return r;
        }
        return PreconditionCheckResult.Pass();
    }

    private static string MapPropertyKey(string? ontologyPredicate)
    {
        if (string.IsNullOrWhiteSpace(ontologyPredicate))
            return Kg.Fields.Label;

        // Known mappings
        if (ontologyPredicate == Ldm.Properties.Status) return Kg.Fields.Status;
        if (ontologyPredicate == Ldm.Properties.Label)  return Kg.Fields.Label;
        if (ontologyPredicate == Ldm.Properties.Kind)   return Kg.Fields.Kind;

        // Fallback: last segment after ":" or "/"
        var s = ontologyPredicate!;
        var idx = Math.Max(s.LastIndexOf(':'), s.LastIndexOf('/'));
        return idx >= 0 && idx < s.Length - 1 ? s[(idx + 1)..] : s;
    }
}
```

---

## `src/LimboDancer.MCP.Graph.CosmosGremlin/Effects.cs`

```csharp
using System;
using System.Collections.Generic;
using System.Threading;
using System.Threading.Tasks;
using LimboDancer.MCP.Ontology;

namespace LimboDancer.MCP.Graph.CosmosGremlin;

public sealed class EffectApplyResult
{
    public bool Applied { get; init; }
    public string? Message { get; init; }

    public static EffectApplyResult Success(string? msg = null) => new() { Applied = true, Message = msg };
    public static EffectApplyResult Skipped(string? msg = null) => new() { Applied = false, Message = msg };
}

/// <summary>
/// Applies ontology-bound ToolEffects to the graph (e.g., update Reservation.status).
/// </summary>
public sealed class EffectsApplier
{
    private readonly GraphStore _graph;

    public EffectsApplier(GraphStore graph) => _graph = graph;

    /// <summary>
    /// Apply a single effect to a concrete subject instance (e.g., Reservation R123).
    /// </summary>
    public async Task<EffectApplyResult> ApplyAsync(
        string subjectLabel,
        string subjectId,
        ToolEffect effect,
        CancellationToken ct = default)
    {
        // Map ontology property -> graph property key
        var propKey = MapPropertyKey(effect.Property);

        // For now we handle property updates; edge creation could be added later if needed.
        await _graph.SetVertexPropertyAsync(subjectId, propKey, effect.NewValue, ct);
        return EffectApplyResult.Success($"Set {propKey} = {effect.NewValue} on {subjectLabel}/{subjectId}");
    }

    /// <summary>
    /// Apply multiple effects, returning the last result (or first failure if you prefer).
    /// </summary>
    public async Task<IReadOnlyList<EffectApplyResult>> ApplyAllAsync(
        string subjectLabel,
        string subjectId,
        IEnumerable<ToolEffect> effects,
        CancellationToken ct = default)
    {
        var results = new List<EffectApplyResult>();
        foreach (var e in effects)
        {
            var r = await ApplyAsync(subjectLabel, subjectId, e, ct);
            results.Add(r);
        }
        return results;
    }

    private static string MapPropertyKey(string ontologyProperty)
    {
        if (ontologyProperty == Ldm.Properties.Status) return Kg.Fields.Status;
        if (ontologyProperty == Ldm.Properties.Label)  return Kg.Fields.Label;
        if (ontologyProperty == Ldm.Properties.Kind)   return Kg.Fields.Kind;

        var s = ontologyProperty ?? "";
        var idx = Math.Max(s.LastIndexOf(':'), s.LastIndexOf('/'));
        return idx >= 0 && idx < s.Length - 1 ? s[(idx + 1)..] : s;
    }
}
```

---

### Usage notes

* **Auth**: Cosmos DB Gremlin typically uses **primary key** auth (as shown). If/when your account supports AAD for Gremlin, you can extend `GremlinClientFactory` to fetch a token and adjust the `GremlinServer` password.
* **Idempotency**: The upsert patterns (`fold()…coalesce(…)`) ensure safe re-runs.
* **Preconditions**: The evaluator currently supports “exists” and “property equals”. You can extend it to support edge existence (e.g., `requires`) if a tool needs it.
* **Effects**: Implemented as property updates for now (e.g., `status = Canceled`). Add edge creation as needed (e.g., `produces` relationships).

If you want, I can add **unit tests** that run against the **Cosmos DB Gremlin Emulator** or a **test double** with recorded responses for the precondition/effect flows.

---

Awesome — here’s a **follow-on section** you can paste into the same document. It adds a self-contained **xUnit** test project that runs against the **Cosmos DB Gremlin Emulator** (or any Cosmos Gremlin account you point it at).

> This satisfies the “**…or a test double**” wording by choosing the **emulator path**. If you want an **in-memory test double** later, I’ll give you a tiny refactor (swap `GremlinClient` → `IGremlinClient` in `GraphStore` and a stub client). For now, these tests require only environment variables and skip automatically if the emulator isn’t present.

---

## ✅ Unit tests for Preconditions/Effects using Cosmos DB Gremlin Emulator

**Project:** `tests/LimboDancer.MCP.Graph.CosmosGremlin.Tests`

### 1) Test project file

`tests/LimboDancer.MCP.Graph.CosmosGremlin.Tests/LimboDancer.MCP.Graph.CosmosGremlin.Tests.csproj`

```xml
<Project Sdk="Microsoft.NET.Sdk">
  <PropertyGroup>
    <TargetFramework>net9.0</TargetFramework>
    <Nullable>enable</Nullable>
    <ImplicitUsings>enable</ImplicitUsings>
  </PropertyGroup>

  <ItemGroup>
    <PackageReference Include="xunit" Version="2.7.1" />
    <PackageReference Include="xunit.runner.visualstudio" Version="2.5.7">
      <PrivateAssets>all</PrivateAssets>
    </PackageReference>
    <PackageReference Include="Gremlin.Net" Version="3.6.5" />
    <PackageReference Include="Xunit.SkippableFact" Version="1.4.13" />
  </ItemGroup>

  <ItemGroup>
    <ProjectReference Include="..\..\src\LimboDancer.MCP.Graph.CosmosGremlin\LimboDancer.MCP.Graph.CosmosGremlin.csproj" />
    <ProjectReference Include="..\..\src\LimboDancer.MCP.Ontology\LimboDancer.MCP.Ontology.csproj" />
  </ItemGroup>
</Project>
```

### 2) Test configuration (env-driven, safe to commit)

These tests **auto-skip** unless the following env vars are set:

* `COSMOS_GREMLIN_HOST` — e.g., `localhost` (emulator) or `youracct.gremlin.cosmos.azure.com`
* `COSMOS_GREMLIN_PORT` — e.g., `8901` (emulator) or `443` (cloud)
* `COSMOS_DB_NAME` — database name
* `COSMOS_GRAPH_NAME` — graph (container) name
* `COSMOS_GREMLIN_KEY` — emulator/account key (for emulator, use the key shown in the emulator UI/logs)

> Tip (emulator): launch it with Gremlin enabled, note the Gremlin endpoint/primary key, and create the **database/graph** once (Gremlin will auto-create on first vertex if permissions allow).

### 3) Emulator fixture (creates a shared client if env is present)

`tests/LimboDancer.MCP.Graph.CosmosGremlin.Tests/EmulatorFixture.cs`

```csharp
using System;
using Gremlin.Net.Driver;
using Xunit;
using Xunit.SkippableFact;
using LimboDancer.MCP.Graph.CosmosGremlin;

public sealed class EmulatorFixture : IAsyncLifetime
{
    public GremlinClient? Client { get; private set; }
    public bool IsConfigured { get; private set; }

    public string Host => Env("COSMOS_GREMLIN_HOST");
    public int Port => int.TryParse(Environment.GetEnvironmentVariable("COSMOS_GREMLIN_PORT"), out var p) ? p : 443;
    public string Db => Env("COSMOS_DB_NAME");
    public string Graph => Env("COSMOS_GRAPH_NAME");
    public string Key => Env("COSMOS_GREMLIN_KEY");

    public async Task InitializeAsync()
    {
        // If any required env is missing, mark as not configured.
        IsConfigured = !string.IsNullOrWhiteSpace(Host)
                    && !string.IsNullOrWhiteSpace(Db)
                    && !string.IsNullOrWhiteSpace(Graph)
                    && !string.IsNullOrWhiteSpace(Key);

        if (!IsConfigured) return;

        var options = new GremlinOptions
        {
            Host = Host,
            Port = Port,
            Database = Db,
            Graph = Graph,
            PrimaryKey = Key
        };

        Client = GremlinClientFactory.Create(options);
        await Task.CompletedTask;
    }

    public Task DisposeAsync()
    {
        Client?.Dispose();
        return Task.CompletedTask;
    }

    private static string Env(string name) => Environment.GetEnvironmentVariable(name) ?? "";
}
```

### 4) GraphStore + Preconditions/Effects tests

`tests/LimboDancer.MCP.Graph.CosmosGremlin.Tests/GraphStore_EmulatorTests.cs`

```csharp
using System;
using System.Collections.Generic;
using System.Threading.Tasks;
using Xunit;
using Xunit.SkippableFact;
using LimboDancer.MCP.Graph.CosmosGremlin;
using LimboDancer.MCP.Ontology;

public class GraphStore_EmulatorTests : IClassFixture<EmulatorFixture>
{
    private readonly EmulatorFixture _fx;

    public GraphStore_EmulatorTests(EmulatorFixture fx) => _fx = fx;

    [SkippableFact]
    public async Task UpsertVerticesAndEdge_Then_CheckEdgeExists()
    {
        Skip.IfNot(_fx.IsConfigured, "Cosmos Gremlin emulator/account not configured via env vars.");

        var store = new GraphStore(_fx.Client!);

        var personId = $"P-{Guid.NewGuid():N}";
        var tripId = $"T-{Guid.NewGuid():N}";
        var resId = $"R-{Guid.NewGuid():N}";

        await store.UpsertPersonAsync(personId, label: "Test Person");
        await store.UpsertTripAsync(tripId, label: "Test Trip");
        await store.UpsertReservationAsync(resId, status: "Active", label: "Test Res");

        await store.UpsertEdgeOwnsAsync(personId, resId);
        await store.UpsertEdgeForTripAsync(resId, tripId);

        var owns = await store.EdgeExistsAsync(personId, Kg.Labels.Owns, resId);
        Assert.True(owns);

        var forTrip = await store.EdgeExistsAsync(resId, Kg.Labels.ForTrip, tripId);
        Assert.True(forTrip);
    }

    [SkippableFact]
    public async Task Preconditions_StatusActive_Passes_Then_Effect_Sets_Canceled()
    {
        Skip.IfNot(_fx.IsConfigured, "Cosmos Gremlin emulator/account not configured via env vars.");

        var store = new GraphStore(_fx.Client!);
        var evaluator = new PreconditionsEvaluator(store);
        var applier = new EffectsApplier(store);

        var resId = $"R-{Guid.NewGuid():N}";
        await store.UpsertReservationAsync(resId, status: "Active", label: "Cancelable Reservation");

        var p = new ToolPrecondition
        {
            Subject = Ldm.Classes.Reservation,
            Predicate = Ldm.Properties.Status,
            Equals = "Active",
            Description = "Reservation must be Active."
        };

        var check1 = await evaluator.EvaluateAsync(Kg.Labels.Reservation, resId, p);
        Assert.True(check1.Ok);

        var effect = new ToolEffect
        {
            Subject = Ldm.Classes.Reservation,
            Property = Ldm.Properties.Status,
            NewValue = "Canceled",
            Label = "Cancel reservation"
        };

        var applied = await applier.ApplyAsync(Kg.Labels.Reservation, resId, effect);
        Assert.True(applied.Applied);

        // Re-check precondition should now fail
        var check2 = await evaluator.EvaluateAsync(Kg.Labels.Reservation, resId, p);
        Assert.False(check2.Ok);
        Assert.Contains("!= Active", check2.Reason ?? "");
    }

    [SkippableFact]
    public async Task SetAndGet_CustomProperty_Works()
    {
        Skip.IfNot(_fx.IsConfigured, "Cosmos Gremlin emulator/account not configured via env vars.");

        var store = new GraphStore(_fx.Client!);

        var resId = $"R-{Guid.NewGuid():N}";
        await store.UpsertReservationAsync(resId, status: "Active", label: "HasLabel");

        // Set a custom property (e.g., 'note')
        await store.SetVertexPropertyAsync(resId, "note", "hello");

        var note = await store.GetVertexPropertyAsync(resId, "note");
        Assert.Equal("hello", note);
    }
}
```

### 5) How to run the tests

```bash
# 1) Start your Cosmos DB emulator with Gremlin enabled (or point to a real account)
#    Take note of: host, port, database, graph, primary key
#
# 2) Export environment variables (example for local emulator):
export COSMOS_GREMLIN_HOST="localhost"
export COSMOS_GREMLIN_PORT="8901"
export COSMOS_DB_NAME="ldm-testdb"
export COSMOS_GRAPH_NAME="ldm-graph"
export COSMOS_GREMLIN_KEY="<your-emulator-or-account-key>"

# 3) Run tests
dotnet test tests/LimboDancer.MCP.Graph.CosmosGremlin.Tests -c Release
```

> If any variable is missing, tests **skip** cleanly (so they won’t fail in CI environments without the emulator).
> You can wire a dedicated **CI job** that spins up the emulator in Docker, exports env vars, and runs this test project; or point it at a non-prod Cosmos account.

---

### (Optional) Want a **pure unit test double** too?

If you want a no-infrastructure test path, I’ll add a tiny refactor:

* Change `GraphStore` ctor to accept **`IGremlinClient`** (Gremlin.Net provides this interface), not the concrete `GremlinClient`.
* Add a `FakeGremlinClient : IGremlinClient` for tests, which stores vertices/edges in memory and responds to the few queries we generate.
* Tests then run fully in-memory (fast, deterministic) and **do not** require the emulator.

Say the word and I’ll include that minimal patch + the fake client.

---


Awesome — here’s the **pure unit-test variation** you can append.

It introduces a **test double** that implements `IGremlinClient` and a small refactor so `GraphStore` depends on the **interface** (not the concrete client). The fake client understands the **exact Gremlin snippets** your store emits and keeps a tiny **in-memory graph** (vertices + edges). No emulator or cloud resources required.

---

## ✅ Variation: switch `GraphStore` to `IGremlinClient` and add a fake client

### 1) Patch: `GraphStore` now uses `IGremlinClient` and non-generic reads

> We keep your gremlin scripts exactly the same, but rely on **non-generic** `SubmitAsync` so the fake can return simple values.

**Replace** `src/LimboDancer.MCP.Graph.CosmosGremlin/GraphStore.cs` with:

```csharp
using System;
using System.Collections.Generic;
using System.Linq;
using System.Threading;
using System.Threading.Tasks;
using Gremlin.Net.Driver;
using LimboDancer.MCP.Ontology;

namespace LimboDancer.MCP.Graph.CosmosGremlin;

public sealed class GraphStore
{
    private readonly IGremlinClient _client;

    public GraphStore(IGremlinClient client) => _client = client ?? throw new ArgumentNullException(nameof(client));

    // ------------------------ Upserts (generic) ------------------------

    public async Task UpsertVertexAsync(string id, string label, IDictionary<string, object?> properties, CancellationToken ct = default)
    {
        var bindings = new Dictionary<string, object?>
        {
            ["id"] = id,
            ["label"] = label
        };

        var propsSequence = "";
        int i = 0;
        foreach (var kv in properties.Where(kv => kv.Value is not null))
        {
            var k = kv.Key;
            var pName = $"p{i++}";
            bindings[pName] = kv.Value;
            propsSequence += $".property('{k}', {pName})";
        }

        var gremlin = "g.V(id).fold()" +
                      ".coalesce(unfold(), addV(label).property(id, id))" +
                      propsSequence;

        await _client.SubmitAsync(gremlin, bindings);
    }

    public async Task UpsertEdgeAsync(string outId, string label, string inId, IDictionary<string, object?>? properties = null, CancellationToken ct = default)
    {
        var bindings = new Dictionary<string, object?>
        {
            ["outId"] = outId,
            ["inId"]  = inId,
            ["label"] = label
        };

        var propsSequence = "";
        if (properties is not null)
        {
            int i = 0;
            foreach (var kv in properties.Where(kv => kv.Value is not null))
            {
                var k = kv.Key;
                var pName = $"p{i++}";
                bindings[pName] = kv.Value;
                propsSequence += $".property('{k}', {pName})";
            }
        }

        var gremlin =
            "g.V(outId).as('a')" +
            ".V(inId).as('b')" +
            ".coalesce(" +
                "select('a').outE(label).where(inV().hasId(inId))," +
                "addE(label).from('a').to('b')" +
            $"){propsSequence}";

        await _client.SubmitAsync(gremlin, bindings);
    }

    public async Task SetVertexPropertyAsync(string id, string propertyKey, object? value, CancellationToken ct = default)
    {
        var bindings = new Dictionary<string, object?>
        {
            ["id"] = id,
            ["k"]  = propertyKey,
            ["v"]  = value
        };
        var gremlin = "g.V(id).property(k, v)";
        await _client.SubmitAsync(gremlin, bindings);
    }

    // ------------------------ Convenience for core labels ------------------------

    public Task UpsertPersonAsync(string id, string? label = null, IDictionary<string, object?>? props = null, CancellationToken ct = default)
        => UpsertVertexAsync(id, Kg.Labels.Person, props ?? DefaultProps(label), ct);

    public Task UpsertTripAsync(string id, string? label = null, IDictionary<string, object?>? props = null, CancellationToken ct = default)
        => UpsertVertexAsync(id, Kg.Labels.Trip, props ?? DefaultProps(label), ct);

    public Task UpsertReservationAsync(string id, string? status = null, string? label = null, IDictionary<string, object?>? props = null, CancellationToken ct = default)
    {
        props ??= new Dictionary<string, object?>();
        if (!string.IsNullOrEmpty(label)) props[Kg.Fields.Label] = label;
        if (!string.IsNullOrEmpty(status)) props[Kg.Fields.Status] = status;
        return UpsertVertexAsync(id, Kg.Labels.Reservation, props, ct);
    }

    public Task UpsertToolAsync(string id, string? label = null, IDictionary<string, object?>? props = null, CancellationToken ct = default)
        => UpsertVertexAsync(id, Kg.Labels.Tool, props ?? DefaultProps(label), ct);

    public Task UpsertSkillAsync(string id, string? label = null, IDictionary<string, object?>? props = null, CancellationToken ct = default)
        => UpsertVertexAsync(id, Kg.Labels.Skill, props ?? DefaultProps(label), ct);

    public Task UpsertEdgeOwnsAsync(string personId, string reservationId, IDictionary<string, object?>? props = null, CancellationToken ct = default)
        => UpsertEdgeAsync(personId, Kg.Labels.Owns, reservationId, props, ct);

    public Task UpsertEdgeForTripAsync(string reservationId, string tripId, IDictionary<string, object?>? props = null, CancellationToken ct = default)
        => UpsertEdgeAsync(reservationId, Kg.Labels.ForTrip, tripId, props, ct);

    public Task UpsertEdgeRequiresAsync(string toolId, string skillId, IDictionary<string, object?>? props = null, CancellationToken ct = default)
        => UpsertEdgeAsync(toolId, Kg.Labels.Requires, skillId, props, ct);

    private static Dictionary<string, object?> DefaultProps(string? label)
    {
        var d = new Dictionary<string, object?>();
        if (!string.IsNullOrWhiteSpace(label)) d[Kg.Fields.Label] = label;
        return d;
    }

    // ------------------------ Simple reads for checks ------------------------

    public async Task<string?> GetVertexPropertyAsync(string id, string propertyKey, CancellationToken ct = default)
    {
        var gremlin = "g.V(id).values(k).limit(1)";
        var bindings = new Dictionary<string, object?> { ["id"] = id, ["k"] = propertyKey };

        var rs = await _client.SubmitAsync(gremlin, bindings); // ResultSet<dynamic>
        var first = rs.FirstOrDefault();
        return first?.ToString();
    }

    public async Task<bool> EdgeExistsAsync(string outId, string label, string inId, CancellationToken ct = default)
    {
        var gremlin = "g.V(outId).outE(label).where(inV().hasId(inId)).limit(1).count()";
        var bindings = new Dictionary<string, object?> { ["outId"] = outId, ["label"] = label, ["inId"] = inId };

        var rs = await _client.SubmitAsync(gremlin, bindings); // ResultSet<dynamic>
        var first = rs.FirstOrDefault();
        var count = first is null ? 0L : Convert.ToInt64(first);
        return count > 0;
    }
}
```

---

### 2) Add a **test-double** `IGremlinClient` for unit tests

**File:** `tests/LimboDancer.MCP.Graph.CosmosGremlin.Tests/Fakes/FakeGremlinClient.cs`

```csharp
using System;
using System.Collections.Concurrent;
using System.Collections.Generic;
using System.Linq;
using System.Threading.Tasks;
using Gremlin.Net.Driver;
using Gremlin.Net.Driver.Messages;

namespace LimboDancer.MCP.Graph.CosmosGremlin.Tests.Fakes;

/// <summary>
/// A minimal in-memory test double for IGremlinClient that understands the exact Gremlin
/// snippets emitted by GraphStore. Not a general-purpose Gremlin interpreter.
/// </summary>
public sealed class FakeGremlinClient : IGremlinClient, IDisposable
{
    private sealed record Vertex(string Id, string Label, ConcurrentDictionary<string, object?> Props);
    private sealed record Edge(string OutId, string Label, string InId, ConcurrentDictionary<string, object?> Props);

    private readonly ConcurrentDictionary<string, Vertex> _v = new();
    private readonly ConcurrentBag<Edge> _e = new();

    public void Dispose() { /* nothing */ }

    // ---- IGremlinClient: generic ----
    public Task<ResultSet<T>> SubmitAsync<T>(string requestScript, IDictionary<string, object>? bindings = null, RequestOptions? requestOptions = null)
    {
        var result = Execute(requestScript, bindings ?? new Dictionary<string, object>());
        var cast = result.Select(x => (T)ConvertTo(typeof(T), x)!).ToList();
        return Task.FromResult(new ResultSet<T>(cast, new Dictionary<string, object>()));
    }

    // ---- IGremlinClient: non-generic ----
    public Task<ResultSet<dynamic>> SubmitAsync(string requestScript, IDictionary<string, object>? bindings = null, RequestOptions? requestOptions = null)
    {
        var result = Execute(requestScript, bindings ?? new Dictionary<string, object>());
        return Task.FromResult(new ResultSet<dynamic>(result, new Dictionary<string, object>()));
    }

    // ---- Minimal "parser" for GraphStore's scripts ----
    private IList<dynamic> Execute(string script, IDictionary<string, object> b)
    {
        // Upsert vertex
        if (script.StartsWith("g.V(id).fold()", StringComparison.Ordinal)
            && script.Contains("addV(label).property(id, id)", StringComparison.Ordinal))
        {
            var id = (string)b["id"];
            var label = (string)b["label"];
            var vtx = _v.GetOrAdd(id, _ => new Vertex(id, label, new()));
            // apply properties p0..pN in appearance order by scanning binding keys
            foreach (var kv in b.Where(kv => kv.Key.StartsWith("p")))
            {
                var propKey = ExtractPropKey(script, kv.Key); // reads preceding ".property('key', pN)"
                if (propKey is not null) vtx.Props[propKey] = kv.Value;
            }
            return Array.Empty<dynamic>();
        }

        // Upsert edge with coalesce
        if (script.StartsWith("g.V(outId).as('a')", StringComparison.Ordinal)
            && script.Contains("addE(label).from('a').to('b')", StringComparison.Ordinal))
        {
            var outId = (string)b["outId"];
            var inId  = (string)b["inId"];
            var label = (string)b["label"];

            if (!_v.ContainsKey(outId) || !_v.ContainsKey(inId))
                throw new InvalidOperationException("Vertices must exist before creating edge.");

            var exists = _e.Any(x => x.OutId == outId && x.InId == inId && x.Label == label);
            if (!exists)
            {
                var props = new ConcurrentDictionary<string, object?>();
                foreach (var kv in b.Where(kv => kv.Key.StartsWith("p")))
                {
                    var propKey = ExtractPropKey(script, kv.Key);
                    if (propKey is not null) props[propKey] = kv.Value;
                }
                _e.Add(new Edge(outId, label, inId, props));
            }
            return Array.Empty<dynamic>();
        }

        // Set vertex property
        if (script == "g.V(id).property(k, v)")
        {
            var id = (string)b["id"];
            var key = (string)b["k"];
            var value = b.ContainsKey("v") ? b["v"] : null;
            if (_v.TryGetValue(id, out var vx))
            {
                vx.Props[key] = value;
            }
            else
            {
                throw new InvalidOperationException($"Vertex {id} not found.");
            }
            return Array.Empty<dynamic>();
        }

        // Get vertex property (single value)
        if (script == "g.V(id).values(k).limit(1)")
        {
            var id = (string)b["id"];
            var key = (string)b["k"];
            if (_v.TryGetValue(id, out var vx) && vx.Props.TryGetValue(key, out var val) && val is not null)
                return new List<dynamic> { val };
            return new List<dynamic>(); // empty => FirstOrDefault null
        }

        // Edge exists count
        if (script == "g.V(outId).outE(label).where(inV().hasId(inId)).limit(1).count()")
        {
            var outId = (string)b["outId"];
            var inId  = (string)b["inId"];
            var label = (string)b["label"];
            var exists = _e.Any(x => x.OutId == outId && x.InId == inId && x.Label == label);
            return new List<dynamic> { exists ? 1L : 0L };
        }

        throw new NotSupportedException($"FakeGremlinClient does not recognize script: {script}");
    }

    private static object? ConvertTo(Type t, object? v)
    {
        if (v is null) return default;
        if (t.IsInstanceOfType(v)) return v;
        if (t == typeof(string)) return v.ToString();
        if (t == typeof(long)) return Convert.ToInt64(v);
        if (t == typeof(int)) return Convert.ToInt32(v);
        if (t == typeof(bool)) return Convert.ToBoolean(v);
        return v;
    }

    // Pulls the property key for binding pN by locating ".property('key', pN)" in the script
    private static string? ExtractPropKey(string script, string pName)
    {
        // very small parser: look for "property('xxx', pN)"
        var token = $"property('";
        var idx = script.IndexOf($"{token}", StringComparison.Ordinal);
        while (idx >= 0)
        {
            var endKey = script.IndexOf("'", idx + token.Length, StringComparison.Ordinal);
            var after = script.IndexOf(",", endKey + 1, StringComparison.Ordinal);
            var pRefStart = script.IndexOf(pName, after, StringComparison.Ordinal);
            if (pRefStart >= 0)
            {
                // this property call belongs to pName
                return script.Substring(idx + token.Length, endKey - (idx + token.Length));
            }
            // search next property occurrence
            idx = script.IndexOf($"{token}", endKey + 1, StringComparison.Ordinal);
        }
        return null;
    }
}
```

> `ResultSet<T>`/`ResultSet<dynamic>` are constructed with in-memory lists; the test double returns exactly what `GraphStore` expects for `.FirstOrDefault()` and ignored write results.

---

### 3) Pure unit tests using the fake client

**File:** `tests/LimboDancer.MCP.Graph.CosmosGremlin.Tests/GraphStore_FakeTests.cs`

```csharp
using System;
using System.Threading.Tasks;
using Xunit;
using LimboDancer.MCP.Graph.CosmosGremlin;
using LimboDancer.MCP.Graph.CosmosGremlin.Tests.Fakes;
using LimboDancer.MCP.Ontology;

public class GraphStore_FakeTests
{
    [Fact]
    public async Task UpsertVerticesEdges_And_Checks_Work_InMemory()
    {
        using var fake = new FakeGremlinClient();
        var store = new GraphStore(fake);

        var personId = $"P-{Guid.NewGuid():N}";
        var tripId   = $"T-{Guid.NewGuid():N}";
        var resId    = $"R-{Guid.NewGuid():N}";

        await store.UpsertPersonAsync(personId, "Test Person");
        await store.UpsertTripAsync(tripId, "Test Trip");
        await store.UpsertReservationAsync(resId, status: "Active", label: "Test Res");

        await store.UpsertEdgeOwnsAsync(personId, resId);
        await store.UpsertEdgeForTripAsync(resId, tripId);

        Assert.True(await store.EdgeExistsAsync(personId, Kg.Labels.Owns, resId));
        Assert.True(await store.EdgeExistsAsync(resId, Kg.Labels.ForTrip, tripId));
    }

    [Fact]
    public async Task Preconditions_And_Effects_Flow_Passes_InMemory()
    {
        using var fake = new FakeGremlinClient();
        var store = new GraphStore(fake);
        var pre  = new PreconditionsEvaluator(store);
        var eff  = new EffectsApplier(store);

        var resId = $"R-{Guid.NewGuid():N}";
        await store.UpsertReservationAsync(resId, status: "Active", label: "Cancelable");

        var p = new ToolPrecondition
        {
            Subject = Ldm.Classes.Reservation,
            Predicate = Ldm.Properties.Status,
            Equals = "Active",
            Description = "Reservation must be Active"
        };

        var chk1 = await pre.EvaluateAsync(Kg.Labels.Reservation, resId, p);
        Assert.True(chk1.Ok);

        var e = new ToolEffect
        {
            Subject = Ldm.Classes.Reservation,
            Property = Ldm.Properties.Status,
            NewValue = "Canceled",
            Label = "Cancel reservation"
        };

        var r = await eff.ApplyAsync(Kg.Labels.Reservation, resId, e);
        Assert.True(r.Applied);

        var chk2 = await pre.EvaluateAsync(Kg.Labels.Reservation, resId, p);
        Assert.False(chk2.Ok);
    }

    [Fact]
    public async Task SetVertexProperty_Then_GetVertexProperty_Returns_Value()
    {
        using var fake = new FakeGremlinClient();
        var store = new GraphStore(fake);

        var resId = $"R-{Guid.NewGuid():N}";
        await store.UpsertReservationAsync(resId, status: "Active", label: "LabelX");

        await store.SetVertexPropertyAsync(resId, "note", "hello");
        var note = await store.GetVertexPropertyAsync(resId, "note");
        Assert.Equal("hello", note);
    }
}
```

---

### 4) Notes

* This variation **does not** change your Cosmos code paths — it only **adds** a no-infra test path.
* The fake is intentionally small and recognizes **only** these scripts:

  * Vertex upsert: `g.V(id).fold().coalesce(unfold(), addV(label).property(id, id))...`
  * Edge upsert: `g.V(outId).as('a').V(inId).as('b').coalesce(select('a').outE(label).where(inV().hasId(inId)), addE(label).from('a').to('b'))...`
  * Set prop: `g.V(id).property(k, v)`
  * Get prop: `g.V(id).values(k).limit(1)`
  * Edge exists: `g.V(outId).outE(label).where(inV().hasId(inId)).limit(1).count()`
* If you ever change those strings, update the fake’s recognizers accordingly (it fails fast with `NotSupportedException` so you’ll notice).

Want me to also wire these **tests into CI** behind a separate job (runs always), while the **emulator tests** run only when env vars are provided?
