# 6. **HTTP transport hardening + SSE events**

   * Files: `src/LimboDancer.MCP.McpServer.Http/{Auth.cs, SseEndpoints.cs}`; wire Entra ID for auth and add `/mcp/events` for progress/trace streaming.
   * Why: It’s the next transport milestone and aligns with your component map. &#x20;
   
   ---
   
   Awesome — here are **PR-ready** files to harden your HTTP transport with **Entra ID (Azure AD) JWT auth** and add **Server-Sent Events** at `/mcp/events` for progress/trace streaming.

They’re drop-in: just add the two files below and call the short wiring snippet in `Program.cs`.

---

## `src/LimboDancer.MCP.McpServer.Http/Auth.cs`

```csharp
using System.Security.Claims;
using Microsoft.AspNetCore.Authentication.JwtBearer;
using Microsoft.AspNetCore.Authorization;
using Microsoft.Extensions.Options;
using Microsoft.IdentityModel.Tokens;

namespace LimboDancer.MCP.McpServer.Http;

public sealed class AuthOptions
{
    /// <summary>Authority base, e.g. "https://login.microsoftonline.com/{tenantId}/v2.0"</summary>
    public string Authority { get; set; } = "";
    /// <summary>Expected audience (App ID URI or Client ID), e.g. "api://{client-id}" or "{client-id}"</summary>
    public string Audience { get; set; } = "";
    /// <summary>Optional explicit issuer list. If empty, Authority is used.</summary>
    public string[]? ValidIssuers { get; set; }
    /// <summary>Allowed CORS origins for the HTTP API and SSE.</summary>
    public string[] AllowedOrigins { get; set; } = Array.Empty<string>();
    /// <summary>Required scope for callers (if using OAuth scopes). Example: "Mcp.Access"</summary>
    public string RequiredScope { get; set; } = "Mcp.Access";
    /// <summary>Operator role (if using Entra App Roles). Example: "Mcp.Operator"</summary>
    public string OperatorRole { get; set; } = "Mcp.Operator";
    /// <summary>Reader role (optional). Example: "Mcp.Reader"</summary>
    public string ReaderRole { get; set; } = "Mcp.Reader";
}

public static class Auth
{
    private const string PolicyReader = "McpReader";
    private const string PolicyOperator = "McpOperator";
    private const string RolesClaim = "roles"; // Entra app-roles appear here
    private const string ScpClaim = "scp";     // OAuth scopes appear here

    /// <summary>Add Entra ID (Azure AD) JWT Bearer auth + CORS + policies.</summary>
    public static IServiceCollection AddEntraIdAuth(this IServiceCollection services, IConfiguration config)
    {
        services.Configure<AuthOptions>(config.GetSection("Auth"));
        var opts = config.GetSection("Auth").Get<AuthOptions>() ?? new();

        services.AddCors(c =>
        {
            c.AddPolicy("mcp-cors", p =>
            {
                if (opts.AllowedOrigins?.Length > 0)
                    p.WithOrigins(opts.AllowedOrigins).AllowAnyMethod().AllowAnyHeader();
                else
                    p.AllowAnyOrigin().AllowAnyHeader().AllowAnyMethod(); // dev-friendly; tighten in prod
            });
        });

        services.AddAuthentication(JwtBearerDefaults.AuthenticationScheme)
            .AddJwtBearer(o =>
            {
                o.Authority = opts.Authority;
                o.Audience = opts.Audience;
                o.TokenValidationParameters = new TokenValidationParameters
                {
                    ValidateIssuer = true,
                    ValidIssuers = (opts.ValidIssuers is { Length: > 0 }) ? opts.ValidIssuers : null,
                    ValidAudience = opts.Audience,
                    ValidateAudience = true,
                    ValidateLifetime = true
                };
                // Enable SSE over fetch with Auth header:
                o.Events = new JwtBearerEvents
                {
                    OnMessageReceived = ctx =>
                    {
                        // Allow ?access_token= for SSE EventSource polyfills if needed (optional)
                        var token = ctx.Request.Query["access_token"];
                        if (!string.IsNullOrEmpty(token) && ctx.HttpContext.Request.Path.StartsWithSegments("/mcp/events"))
                            ctx.Token = token!;
                        return Task.CompletedTask;
                    }
                };
            });

        services.AddAuthorization(auth =>
        {
            auth.AddPolicy(PolicyReader, policy =>
            {
                policy.RequireAssertion(ctx =>
                {
                    // Allowed if scope present OR reader/operator role present
                    var hasScope = HasScope(ctx.User, opts.RequiredScope);
                    var hasReader = HasRole(ctx.User, opts.ReaderRole) || HasRole(ctx.User, opts.OperatorRole);
                    return hasScope || hasReader;
                });
            });

            auth.AddPolicy(PolicyOperator, policy =>
            {
                policy.RequireAssertion(ctx =>
                {
                    var hasScope = HasScope(ctx.User, opts.RequiredScope); // keep scope acceptable for operator too
                    var hasOperator = HasRole(ctx.User, opts.OperatorRole);
                    return hasOperator || hasScope;
                });
            });
        });

        return services;
    }

    /// <summary>Enable CORS, AuthN, AuthZ middlewares.</summary>
    public static IApplicationBuilder UseEntraIdAuth(this IApplicationBuilder app)
    {
        app.UseCors("mcp-cors");
        app.UseAuthentication();
        app.UseAuthorization();
        return app;
    }

    public static string ReaderPolicy => PolicyReader;
    public static string OperatorPolicy => PolicyOperator;

    private static bool HasRole(ClaimsPrincipal user, string role) =>
        !string.IsNullOrWhiteSpace(role) &&
        user.FindAll(RolesClaim).Any(c => c.Value.Split(' ').Contains(role, StringComparer.OrdinalIgnoreCase));

    private static bool HasScope(ClaimsPrincipal user, string scope) =>
        !string.IsNullOrWhiteSpace(scope) &&
        user.FindAll(SCpClaim).Any(c => c.Value.Split(' ').Contains(scope, StringComparer.OrdinalIgnoreCase));
}
```

---

## `src/LimboDancer.MCP.McpServer.Http/SseEndpoints.cs`

```csharp
using System.Buffers;
using System.Text;
using System.Text.Json;
using System.Threading.Channels;
using Microsoft.AspNetCore.Authorization;

namespace LimboDancer.MCP.McpServer.Http;

/// <summary>Simple SSE message payload.</summary>
public sealed record SseMessage(
    string Event,          // e.g., "progress", "trace", "audit", "ping"
    string Id,             // monotonic id string for Last-Event-ID resume (client-provided or generated)
    object Data,           // arbitrary object serialized as JSON
    int? RetryMs = null    // optional reconnection time hint
);

/// <summary>Lightweight in-memory event hub with per-topic broadcast.</summary>
public interface IServerEventHub
{
    /// <summary>Publish one message to a topic.</summary>
    Task PublishAsync(string topic, SseMessage message, CancellationToken ct = default);

    /// <summary>Subscribe to a topic as an async stream. lastEventId is advisory (no replay in thin-slice).</summary>
    IAsyncEnumerable<SseMessage> SubscribeAsync(string topic, string? lastEventId, CancellationToken ct = default);
}

public sealed class InMemoryServerEventHub : IServerEventHub
{
    private sealed class Topic
    {
        public Channel<SseMessage> Channel { get; } = Channel.CreateUnbounded<SseMessage>(
            new UnboundedChannelOptions { SingleReader = false, SingleWriter = false });
    }

    private readonly Dictionary<string, Topic> _topics = new(StringComparer.OrdinalIgnoreCase);
    private readonly object _gate = new();

    private Topic GetOrCreate(string topic)
    {
        lock (_gate)
        {
            if (!_topics.TryGetValue(topic, out var t))
            {
                t = new Topic();
                _topics[topic] = t;
            }
            return t;
        }
    }

    public Task PublishAsync(string topic, SseMessage message, CancellationToken ct = default)
    {
        var t = GetOrCreate(topic);
        // Fire-and-forget; if no subscribers, message is buffered (unbounded)
        t.Channel.Writer.TryWrite(message);
        return Task.CompletedTask;
    }

    public async IAsyncEnumerable<SseMessage> SubscribeAsync(string topic, string? lastEventId, [System.Runtime.CompilerServices.EnumeratorCancellation] CancellationToken ct = default)
    {
        // Thin-slice: ignore lastEventId (no replay buffer); future: ring-buffer per topic.
        var t = GetOrCreate(topic);
        while (!ct.IsCancellationRequested)
        {
            if (await t.Channel.Reader.WaitToReadAsync(ct).ConfigureAwait(false))
            {
                while (t.Channel.Reader.TryRead(out var msg))
                    yield return msg;
            }
        }
    }
}

public static class SseEndpoints
{
    /// <summary>Register SSE infra and endpoints.</summary>
    public static IServiceCollection AddSse(this IServiceCollection services)
    {
        services.AddSingleton<IServerEventHub, InMemoryServerEventHub>();
        return services;
    }

    /// <summary>Map GET /mcp/events and POST /mcp/events/publish (for operators/testing).</summary>
    public static IEndpointRouteBuilder MapSseEndpoints(this IEndpointRouteBuilder app, string readerPolicy, string operatorPolicy)
    {
        var group = app.MapGroup("/mcp").WithTags("MCP");

        // GET /mcp/events?topic=...  (SSE)
        group.MapGet("/events", [Authorize(Policy = nameof(readerPolicy))] async (HttpContext ctx, IServerEventHub hub, CancellationToken ct) =>
        {
            // Determine topic: default per-user principal, or query string override
            var topic = ctx.Request.Query["topic"].FirstOrDefault()
                        ?? ctx.User.Identity?.Name
                        ?? ctx.User.FindFirst("oid")?.Value
                        ?? "global";

            var lastEventId = ctx.Request.Headers["Last-Event-ID"].FirstOrDefault();

            ctx.Response.Headers.CacheControl = "no-cache";
            ctx.Response.Headers.Pragma = "no-cache";
            ctx.Response.Headers["X-Accel-Buffering"] = "no";
            ctx.Response.Headers.Connection = "keep-alive";
            ctx.Response.ContentType = "text/event-stream; charset=utf-8";

            // Initial retry hint (3s) for clients
            await WriteRetryAsync(ctx.Response, 3000, ct);

            using var pingTimer = new PeriodicTimer(TimeSpan.FromSeconds(15));
            var sending = Task.Run(async () =>
            {
                await foreach (var msg in hub.SubscribeAsync(topic, lastEventId, ct))
                {
                    await WriteEventAsync(ctx.Response, msg, ct);
                }
            }, ct);

            try
            {
                while (await pingTimer.WaitForNextTickAsync(ct))
                {
                    // keep-alive ping
                    var ping = new SseMessage("ping", DateTimeOffset.UtcNow.ToUnixTimeMilliseconds().ToString(), new { });
                    await WriteEventAsync(ctx.Response, ping, ct);
                }
            }
            catch (OperationCanceledException) { /* client disconnected */ }
            finally
            {
                // let the sending loop finish if it was running
                try { await sending; } catch { /* ignore */ }
            }
        })
        .WithName("SseEvents")
        .RequireAuthorization(readerPolicy);

        // POST /mcp/events/publish (operator tool to push manual messages)
        group.MapPost("/events/publish", [Authorize(Policy = nameof(operatorPolicy))] async (
            HttpContext ctx,
            IServerEventHub hub,
            PublishRequest req,
            CancellationToken ct) =>
        {
            var topic = string.IsNullOrWhiteSpace(req.Topic)
                ? (ctx.User.Identity?.Name ?? "global")
                : req.Topic;

            var id = string.IsNullOrWhiteSpace(req.Id) ? Guid.NewGuid().ToString("N") : req.Id!;
            var retry = (int?)null;
            if (req.RetryMs is > 0) retry = req.RetryMs;

            await hub.PublishAsync(topic, new SseMessage(
                Event: string.IsNullOrWhiteSpace(req.Event) ? "message" : req.Event!,
                Id: id,
                Data: req.Data ?? new { },
                RetryMs: retry), ct);

            return Results.Accepted();
        })
        .WithName("SsePublish")
        .RequireAuthorization(operatorPolicy);

        return app;
    }

    public sealed class PublishRequest
    {
        public string? Topic { get; set; }
        public string? Event { get; set; }     // "progress" | "trace" | "audit" | "message"
        public string? Id { get; set; }        // optional caller-provided id
        public int? RetryMs { get; set; }      // optional EventSource retry hint
        public object? Data { get; set; }      // arbitrary JSON payload
    }

    // ---------------------- Low-level SSE writers ----------------------

    private static async Task WriteRetryAsync(HttpResponse resp, int retryMs, CancellationToken ct)
    {
        await resp.WriteAsync($"retry: {retryMs}\n\n", ct);
        await resp.Body.FlushAsync(ct);
    }

    private static async Task WriteEventAsync(HttpResponse resp, SseMessage msg, CancellationToken ct)
    {
        // Serialize the Data object as a single JSON line; escape as needed
        var json = JsonSerializer.Serialize(msg.Data);
        // id + event + data … blank line terminator
        if (!string.IsNullOrEmpty(msg.Id))
            await resp.WriteAsync($"id: {msg.Id}\n", ct);

        if (!string.IsNullOrEmpty(msg.Event))
            await resp.WriteAsync($"event: {msg.Event}\n", ct);

        // "data:" lines must not contain raw newlines; we send as one JSON line
        await resp.WriteAsync($"data: {json}\n\n", ct);

        if (msg.RetryMs is > 0)
            await resp.WriteAsync($"retry: {msg.RetryMs}\n\n", ct);

        await resp.Body.FlushAsync(ct);
    }
}
```

---

## How to wire it (minimal)

**`Program.cs` (HTTP server)**

```csharp
using LimboDancer.MCP.McpServer.Http;

var builder = WebApplication.CreateBuilder(args);

// 1) AuthN/AuthZ + CORS
builder.Services.AddEntraIdAuth(builder.Configuration);

// 2) SSE hub + endpoints
builder.Services.AddSse();

var app = builder.Build();

// Order matters: CORS -> AuthN/AuthZ -> endpoints
app.UseEntraIdAuth();

// Map SSE (reader policy for GET, operator policy for POST)
app.MapSseEndpoints(Auth.ReaderPolicy, Auth.OperatorPolicy);

// your existing MCP endpoints go here…
app.Run();
```

---

## Example `appsettings.Development.json`

```json
{
  "Auth": {
    "Authority": "https://login.microsoftonline.com/<tenant-id>/v2.0",
    "Audience": "api://<app-id-or-client-id>",
    "ValidIssuers": [
      "https://login.microsoftonline.com/<tenant-id>/v2.0",
      "https://sts.windows.net/<tenant-id>/"
    ],
    "AllowedOrigins": ["https://localhost:5173", "https://localhost:7080"],
    "RequiredScope": "Mcp.Access",
    "OperatorRole": "Mcp.Operator",
    "ReaderRole": "Mcp.Reader"
  }
}
```

> In Entra:
> • If you use **App Roles**, assign users/apps to `Mcp.Reader` and/or `Mcp.Operator`.
> • If you use **OAuth scopes**, expose API scope `Mcp.Access` and grant it to clients.
> The policy logic accepts **either** (scope OR role) for reader; operator requires role or scope.

---

## How to publish events from your server code

Anywhere in your handlers/services:

```csharp
public sealed class ToolProgressNotifier(IServerEventHub hub, IHttpContextAccessor accessor)
{
    public async Task NotifyAsync(string evt, object data, string? topic = null, CancellationToken ct = default)
    {
        topic ??= accessor.HttpContext?.User.Identity?.Name ?? "global";
        var id = DateTimeOffset.UtcNow.ToUnixTimeMilliseconds().ToString();
        await hub.PublishAsync(topic!, new SseMessage(evt, id, data), ct);
    }
}

// Example usage inside a tool:
// await notifier.NotifyAsync("progress", new { step = "embedding", percent = 25 });
```

Front-ends can consume with the native **EventSource** API:

```js
const es = new EventSource("/mcp/events?topic=my-session", { withCredentials: false });
es.addEventListener("progress", (e) => {
  const payload = JSON.parse(e.data);
  console.log("progress:", payload);
});
es.addEventListener("ping", () => { /* keep-alive */ });
```

---

### Security & ops notes

* **CORS**: tighten `AllowedOrigins` in prod.
* **Backpressure**: the built-in hub is unbounded. For prod, switch to a bounded channel + drop/overflow strategy or forward to an external bus.
* **Replay**: thin-slice ignores `Last-Event-ID`. Add a small ring buffer per topic if you need catch-up.
* **Auth**: `/mcp/events` requires **Reader** policy; `/mcp/events/publish` requires **Operator**. Adjust policies to your needs.

This gives you a secure, Entra-protected HTTP layer and a clean **SSE** pipe for live progress/trace without WebSockets.
