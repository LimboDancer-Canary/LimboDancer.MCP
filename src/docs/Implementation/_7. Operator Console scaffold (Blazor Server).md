# 7. **Operator Console scaffold (Blazor Server)**

   * Files: `src/LimboDancer.MCP.BlazorConsole/Pages/{Sessions.razor, Memory.razor, Graph.razor, Ingestion.razor}`, shared data clients.
   * Start with read-only grids: sessions/messages (from Postgres), vector items (from AI Search), KG explorer (read).
   * Why: It’s the first step toward Milestone 9 and helps validation/debugging early. &#x20;
   
   ---
   
   Awesome — here’s a **ready-to-drop** Operator Console scaffold for **Blazor Server** with four pages and lightweight data clients. It’s read-only and wires into your existing Postgres (EF), Azure AI Search, and Cosmos Gremlin layers.

---

## Shared data clients (register in DI)

### `src/LimboDancer.MCP.BlazorConsole/Services/SessionsService.cs`

```csharp
using LimboDancer.MCP.Storage;
using Microsoft.EntityFrameworkCore;

namespace LimboDancer.MCP.BlazorConsole.Services;

public sealed record SessionRow(Guid Id, string UserId, DateTime CreatedAt, int MessageCount);
public sealed record MessageRow(Guid Id, string Role, string Content, DateTime CreatedAt);

public sealed class SessionsService(ChatDbContext db)
{
    public async Task<List<SessionRow>> GetRecentSessionsAsync(int take = 50, CancellationToken ct = default)
    {
        take = Math.Clamp(take, 1, 200);
        return await db.Sessions.AsNoTracking()
            .OrderByDescending(s => s.CreatedAt)
            .Take(take)
            .Select(s => new SessionRow(
                s.Id, s.UserId, s.CreatedAt,
                db.Messages.Count(m => m.SessionId == s.Id)))
            .ToListAsync(ct);
    }

    public async Task<List<MessageRow>> GetMessagesAsync(Guid sessionId, int take = 200, CancellationToken ct = default)
    {
        take = Math.Clamp(take, 1, 1000);
        return await db.Messages.AsNoTracking()
            .Where(m => m.SessionId == sessionId)
            .OrderBy(m => m.CreatedAt)
            .Take(take)
            .Select(m => new MessageRow(m.Id, m.Role.ToString(), m.Content, m.CreatedAt))
            .ToListAsync(ct);
    }
}
```

### `src/LimboDancer.MCP.BlazorConsole/Services/MemoryService.cs`

```csharp
using Azure;
using Azure.Search.Documents;
using Azure.Search.Documents.Models;

namespace LimboDancer.MCP.BlazorConsole.Services;

public sealed record VectorItemRow(
    string Id, string? Title, string Source, int? Chunk, string? OntologyClass, string? Uri,
    IReadOnlyList<string>? Tags, string Preview, double? Score);

public sealed record SourceBucket(string Source, long Count);

public sealed class MemoryService(SearchClient client)
{
    public async Task<List<VectorItemRow>> SearchAsync(
        string? query, int k = 20, string? ontologyClass = null, string? tag = null, CancellationToken ct = default)
    {
        var filterParts = new List<string>();
        if (!string.IsNullOrWhiteSpace(ontologyClass)) filterParts.Add($"ontologyClass eq '{Esc(ontologyClass)}'");
        if (!string.IsNullOrWhiteSpace(tag)) filterParts.Add($"tags/any(t: t eq '{Esc(tag)}')");
        var filter = filterParts.Count > 0 ? string.Join(" and ", filterParts) : null;

        var opts = new SearchOptions
        {
            Size = Math.Clamp(k, 1, 50),
            QueryType = SearchQueryType.Simple,
            Filter = filter
        };
        opts.SearchFields.Add("title");
        opts.SearchFields.Add("content");

        var resp = await client.SearchAsync<SearchDocument>(string.IsNullOrWhiteSpace(query) ? "*" : query, opts, ct);
        var rows = new List<VectorItemRow>();
        await foreach (var r in resp.Value.GetResultsAsync())
        {
            var d = r.Document;
            var content = d.TryGetValue("content", out var cobj) ? cobj?.ToString() ?? "" : "";
            var preview = content.Length > 200 ? content[..200] + "…" : content;
            rows.Add(new VectorItemRow(
                Id: d["id"]?.ToString() ?? "",
                Title: d.TryGetValue("title", out var tobj) ? tobj?.ToString() : null,
                Source: d.TryGetValue("source", out var sobj) ? sobj?.ToString() ?? "" : "",
                Chunk: d.TryGetValue("chunk", out var ch) ? (int?)Convert.ToInt32(ch) : null,
                OntologyClass: d.TryGetValue("ontologyClass", out var oc) ? oc?.ToString() : null,
                Uri: d.TryGetValue("uri", out var u) ? u?.ToString() : null,
                Tags: d.TryGetValue("tags", out var tg) ? ((IEnumerable<object?>)tg).Select(x=>x?.ToString()??"").ToList() : null,
                Preview: preview,
                Score: r.Score));
        }
        return rows;
    }

    public async Task<List<SourceBucket>> TopSourcesAsync(int top = 20, CancellationToken ct = default)
    {
        var opts = new SearchOptions { Size = 0 };
        opts.Facets.Add($"source,count:{Math.Clamp(top,1,100)}");
        var resp = await client.SearchAsync<SearchDocument>("*", opts, ct);
        var f = await resp.Value.GetFacetsAsync();
        var buckets = f.Facets["source"].Select(v => new SourceBucket(v.Value?.ToString() ?? "", v.Count ?? 0)).ToList();
        return buckets;
    }

    private static string Esc(string s) => s.Replace("'", "''");
}
```

### `src/LimboDancer.MCP.BlazorConsole/Services/GraphService.cs`

```csharp
using Gremlin.Net.Driver;

namespace LimboDancer.MCP.BlazorConsole.Services;

public sealed record VertexRow(string Id, string Label, Dictionary<string, object?> Props);
public sealed record EdgeRow(string OutId, string Label, string InId);

public sealed class GraphService(IGremlinClient client)
{
    public async Task<List<VertexRow>> GetVerticesAsync(string label, int take = 50, CancellationToken ct = default)
    {
        var script = "g.V().hasLabel(lbl).limit(t).project('id','label','props').by(id()).by(label()).by(valueMap())";
        var bind = new Dictionary<string, object?> { ["lbl"] = label, ["t"] = Math.Clamp(take,1,200) };
        var rs = await client.SubmitAsync<dynamic>(script, bind);
        var rows = new List<VertexRow>();
        foreach (var r in rs)
        {
            // r is a Map<string, object>; GraphSON->dynamic: expect id/label/props
            var id = r["id"].ToString();
            var lab = r["label"].ToString();
            var dict = new Dictionary<string, object?>();
            foreach (var kv in (IDictionary<string, object?>)r["props"])
            {
                // valueMap gives arrays; unwrap singletons
                var val = kv.Value;
                if (val is IEnumerable<object?> arr && arr is not string)
                    dict[kv.Key] = arr.Cast<object?>().FirstOrDefault();
                else
                    dict[kv.Key] = val;
            }
            rows.Add(new VertexRow(id, lab, dict));
        }
        return rows;
    }

    public async Task<List<EdgeRow>> GetOutEdgesAsync(string id, int take = 50, CancellationToken ct = default)
    {
        var script = "g.V(id).outE().limit(t).project('out','label','in').by(outV().id()).by(label()).by(inV().id())";
        var bind = new Dictionary<string, object?> { ["id"] = id, ["t"] = Math.Clamp(take,1,200) };
        var rs = await client.SubmitAsync<dynamic>(script, bind);
        var rows = new List<EdgeRow>();
        foreach (var r in rs)
            rows.Add(new EdgeRow(r["out"].ToString(), r["label"].ToString(), r["in"].ToString()));
        return rows;
    }
}
```

---

## Pages

### `src/LimboDancer.MCP.BlazorConsole/Pages/Sessions.razor`

```razor
@page "/sessions"
@using LimboDancer.MCP.BlazorConsole.Services
@inject SessionsService Sessions

<h1 class="text-2xl font-semibold mb-4">Sessions</h1>

<div class="flex gap-3 items-end mb-4">
  <label>Show
    <input type="number" class="border rounded px-2 py-1 w-24" @bind="takeSessions" />
  </label>
  <button class="border rounded px-3 py-1" @onclick="LoadSessions">Load</button>
</div>

@if (list is null)
{
  <p>Loading…</p>
}
else
{
  <div class="grid grid-cols-2 gap-6">
    <div>
      <h2 class="font-semibold mb-2">Recent Sessions</h2>
      <table class="min-w-full text-sm">
        <thead><tr class="text-left border-b"><th>Id</th><th>User</th><th>Created</th><th>#Msgs</th></tr></thead>
        <tbody>
          @foreach (var s in list)
          {
            <tr class="border-b hover:bg-gray-50 cursor-pointer" @onclick="() => Select(s)">
              <td class="py-1 pr-3">@s.Id</td>
              <td class="py-1 pr-3">@s.UserId</td>
              <td class="py-1 pr-3">@s.CreatedAt.ToString("u")</td>
              <td class="py-1 pr-3">@s.MessageCount</td>
            </tr>
          }
        </tbody>
      </table>
    </div>

    <div>
      <h2 class="font-semibold mb-2">Messages for @selectedId</h2>
      @if (messages is null)
      {
        <p>Select a session…</p>
      }
      else
      {
        <table class="min-w-full text-sm">
          <thead><tr class="text-left border-b"><th>When</th><th>Role</th><th>Content</th></tr></thead>
          <tbody>
            @foreach (var m in messages)
            {
              <tr class="border-b align-top">
                <td class="py-1 pr-3">@m.CreatedAt.ToString("u")</td>
                <td class="py-1 pr-3">@m.Role</td>
                <td class="py-1 pr-3 whitespace-pre-wrap">@m.Content</td>
              </tr>
            }
          </tbody>
        </table>
      }
    </div>
  </div>
}

@code {
  private int takeSessions = 50;
  private List<SessionRow>? list;
  private Guid? selectedId;
  private List<MessageRow>? messages;

  protected override async Task OnInitializedAsync() => await LoadSessions();

  private async Task LoadSessions()
  {
    list = await Sessions.GetRecentSessionsAsync(takeSessions);
    StateHasChanged();
  }

  private async Task Select(SessionRow s)
  {
    selectedId = s.Id;
    messages = await Sessions.GetMessagesAsync(s.Id);
  }
}
```

### `src/LimboDancer.MCP.BlazorConsole/Pages/Memory.razor`

```razor
@page "/memory"
@using LimboDancer.MCP.BlazorConsole.Services
@inject MemoryService Memory

<h1 class="text-2xl font-semibold mb-4">Memory (Azure AI Search)</h1>

<div class="flex gap-3 items-end mb-4">
  <input class="border rounded px-2 py-1 w-96" placeholder="Query (BM25/Semantic)" @bind="query" />
  <input class="border rounded px-2 py-1" placeholder="ontologyClass (optional)" @bind="ontologyClass" />
  <input class="border rounded px-2 py-1" placeholder="tag (optional)" @bind="tag" />
  <label>K
    <input type="number" class="border rounded px-2 py-1 w-20" @bind="k" />
  </label>
  <button class="border rounded px-3 py-1" @onclick="Search">Search</button>
</div>

@if (items is null)
{
  <p>Enter a query and click Search.</p>
}
else
{
  <table class="min-w-full text-sm">
    <thead>
      <tr class="text-left border-b">
        <th>Score</th><th>Title</th><th>Source#Chunk</th><th>Class</th><th>Tags</th><th>Preview</th>
      </tr>
    </thead>
    <tbody>
      @foreach (var r in items)
      {
        <tr class="border-b align-top">
          <td class="py-1 pr-3">@r.Score?.ToString("F3")</td>
          <td class="py-1 pr-3">@r.Title</td>
          <td class="py-1 pr-3">@r.Source#@r.Chunk</td>
          <td class="py-1 pr-3">@r.OntologyClass</td>
          <td class="py-1 pr-3">@string.Join(", ", r.Tags ?? Array.Empty<string>())</td>
          <td class="py-1 pr-3 whitespace-pre-wrap">@r.Preview</td>
        </tr>
      }
    </tbody>
  </table>

  <h2 class="text-xl font-semibold mt-6 mb-2">Top Sources</h2>
  @if (sources is null)
  {
    <p>—</p>
  }
  else
  {
    <ul class="list-disc pl-6">
      @foreach (var s in sources)
      {
        <li><b>@s.Source</b> — @s.Count</li>
      }
    </ul>
  }
}

@code {
  private string? query;
  private string? ontologyClass;
  private string? tag;
  private int k = 20;
  private List<VectorItemRow>? items;
  private List<SourceBucket>? sources;

  private async Task Search()
  {
    items = await Memory.SearchAsync(query, k, ontologyClass, tag);
    sources = await Memory.TopSourcesAsync(20);
  }
}
```

### `src/LimboDancer.MCP.BlazorConsole/Pages/Graph.razor`

```razor
@page "/graph"
@using LimboDancer.MCP.BlazorConsole.Services
@inject GraphService Graph

<h1 class="text-2xl font-semibold mb-4">Knowledge Graph (read-only)</h1>

<div class="flex gap-3 items-end mb-4">
  <select class="border rounded px-2 py-1" @bind="label">
    <option>Person</option>
    <option>Trip</option>
    <option>Reservation</option>
    <option>Tool</option>
    <option>Skill</option>
  </select>
  <label>Take
    <input type="number" class="border rounded px-2 py-1 w-24" @bind="take" />
  </label>
  <button class="border rounded px-3 py-1" @onclick="Load">Load</button>
</div>

@if (vertices is null)
{
  <p>Click Load.</p>
}
else
{
  <div class="grid grid-cols-2 gap-6">
    <div>
      <h2 class="font-semibold mb-2">@label vertices</h2>
      <table class="min-w-full text-sm">
        <thead>
          <tr class="text-left border-b">
            <th>Id</th><th>Label</th><th>Props</th>
          </tr>
        </thead>
        <tbody>
          @foreach (var v in vertices)
          {
            <tr class="border-b hover:bg-gray-50 cursor-pointer" @onclick="() => Select(v.Id)">
              <td class="py-1 pr-3">@v.Id</td>
              <td class="py-1 pr-3">@v.Label</td>
              <td class="py-1 pr-3">
                @foreach (var kv in v.Props)
                {
                  <div><b>@kv.Key</b>: @kv.Value</div>
                }
              </td>
            </tr>
          }
        </tbody>
      </table>
    </div>
    <div>
      <h2 class="font-semibold mb-2">Outgoing edges for @selectedId</h2>
      @if (edges is null)
      {
        <p>Select a vertex…</p>
      }
      else
      {
        <table class="min-w-full text-sm">
          <thead><tr class="text-left border-b"><th>Out</th><th>Label</th><th>In</th></tr></thead>
          <tbody>
            @foreach (var e in edges)
            {
              <tr class="border-b">
                <td class="py-1 pr-3">@e.OutId</td>
                <td class="py-1 pr-3">@e.Label</td>
                <td class="py-1 pr-3">@e.InId</td>
              </tr>
            }
          </tbody>
        </table>
      }
    </div>
  </div>
}

@code {
  private string label = "Reservation";
  private int take = 50;
  private List<VertexRow>? vertices;
  private string? selectedId;
  private List<EdgeRow>? edges;

  private async Task Load()
  {
    vertices = await Graph.GetVerticesAsync(label, take);
    selectedId = null;
    edges = null;
  }

  private async Task Select(string id)
  {
    selectedId = id;
    edges = await Graph.GetOutEdgesAsync(id);
  }
}
```

### `src/LimboDancer.MCP.BlazorConsole/Pages/Ingestion.razor`

```razor
@page "/ingestion"
@using LimboDancer.MCP.BlazorConsole.Services
@inject MemoryService Memory

<h1 class="text-2xl font-semibold mb-4">Ingestion Overview</h1>

<p class="mb-4 text-sm text-gray-600">
  Read-only snapshot of your memory index: top sources and a sample of recent items.
</p>

<button class="border rounded px-3 py-1 mb-4" @onclick="Reload">Refresh</button>

<h2 class="text-xl font-semibold mb-2">Top Sources</h2>
@if (sources is null)
{
  <p>—</p>
}
else
{
  <table class="min-w-full text-sm">
    <thead><tr class="text-left border-b"><th>Source</th><th>Count</th></tr></thead>
    <tbody>
    @foreach (var s in sources)
    {
      <tr class="border-b"><td class="py-1 pr-3">@s.Source</td><td class="py-1 pr-3">@s.Count</td></tr>
    }
    </tbody>
  </table>
}

<h2 class="text-xl font-semibold mt-6 mb-2">Sample Items</h2>
@if (items is null)
{
  <p>—</p>
}
else
{
  <table class="min-w-full text-sm">
    <thead><tr class="text-left border-b">
      <th>Title</th><th>Source#Chunk</th><th>Class</th><th>Preview</th>
    </tr></thead>
    <tbody>
    @foreach (var r in items)
    {
      <tr class="border-b align-top">
        <td class="py-1 pr-3">@r.Title</td>
        <td class="py-1 pr-3">@r.Source#@r.Chunk</td>
        <td class="py-1 pr-3">@r.OntologyClass</td>
        <td class="py-1 pr-3 whitespace-pre-wrap">@r.Preview</td>
      </tr>
    }
    </tbody>
  </table>
}

@code {
  private List<SourceBucket>? sources;
  private List<VectorItemRow>? items;

  protected override async Task OnInitializedAsync() => await Reload();

  private async Task Reload()
  {
    sources = await Memory.TopSourcesAsync(25);
    items = await Memory.SearchAsync(query: "*", k: 25);
  }
}
```

---

## Minimal wiring

### `src/LimboDancer.MCP.BlazorConsole/Program.cs` (essentials only)

```csharp
using Azure;
using Azure.Search.Documents;
using Gremlin.Net.Driver;
using LimboDancer.MCP.BlazorConsole.Services;
using LimboDancer.MCP.Graph.CosmosGremlin;
using LimboDancer.MCP.Storage;

var builder = WebApplication.CreateBuilder(args);

// Razor + Blazor Server
builder.Services.AddRazorPages();
builder.Services.AddServerSideBlazor();

// Storage (reuse your existing AddPersistence in the host if shared; otherwise add DbContext here)
builder.Services.AddDbContext<ChatDbContext>(options =>
{
    var cs = builder.Configuration.GetConnectionString("Postgres") 
             ?? builder.Configuration["Persistence:ConnectionString"];
    options.UseNpgsql(cs);
});

// Azure AI Search client
builder.Services.AddSingleton<SearchClient>(sp =>
{
    var endpoint = new Uri(builder.Configuration["Search:Endpoint"]!);
    var key = new AzureKeyCredential(builder.Configuration["Search:ApiKey"]!);
    var index = builder.Configuration["Search:Index"] ?? "ldm-memory";
    return new SearchClient(endpoint, index, key);
});

// Gremlin client (read-only)
builder.Services.AddSingleton<IGremlinClient>(sp =>
{
    var opts = new GremlinOptions
    {
        Host     = builder.Configuration["Gremlin:Host"]!,
        Port     = int.TryParse(builder.Configuration["Gremlin:Port"], out var p) ? p : 443,
        Database = builder.Configuration["Gremlin:Database"]!,
        Graph    = builder.Configuration["Gremlin:Graph"]!,
        PrimaryKey = builder.Configuration["Gremlin:Key"]!
    };
    return GremlinClientFactory.Create(opts);
});

// Services
builder.Services.AddScoped<SessionsService>();
builder.Services.AddScoped<MemoryService>();
builder.Services.AddScoped<GraphService>();

var app = builder.Build();
app.MapBlazorHub();
app.MapFallbackToPage("/_Host");
app.Run();
```

### `appsettings.Development.json` (console)

```json
{
  "ConnectionStrings": {
    "Postgres": "Host=localhost;Port=5432;Database=limbodancer_dev;Username=postgres;Password=postgres"
  },
  "Search": {
    "Endpoint": "https://<search>.search.windows.net",
    "ApiKey": "<key>",
    "Index": "ldm-memory"
  },
  "Gremlin": {
    "Host": "youracct.gremlin.cosmos.azure.com",
    "Port": "443",
    "Database": "ldm",
    "Graph": "kg",
    "Key": "<cosmos-primary-key>"
  }
}
```

---

## Notes / next steps

* These pages are **read-only** by design. When you’re ready, we can add:

  * Row “drill-in” (e.g., open full doc from Search, show message tool calls).
  * Filters: date ranges, user id, ontology facets.
  * Live status via `/mcp/events` SSE (e.g., show ingestion progress).
* Styling is intentionally simple; if you use Tailwind in the app, it will pick up classes like `text-2xl`, `grid`, etc.

If you want, I can also add a quick **NavMenu** entries and a minimal **\_Host.cshtml** scaffold for first run.
